<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Severe Weather Visualisations</title>

  <!-- Vega / Vega-Lite / Vega-Embed -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-tooltip@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script> <!-- we use this to calculate projections and ensure annotations remain in the correct position -->

  <style>
    /* Basic tooltip element and visibility behavior (matches plugin expectations) */
    #vg-tooltip-element {
      visibility: hidden;
      position: fixed;
      z-index: 9999;
      padding: 10px 12px;
      max-width: 360px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.12);
      border: 1px solid rgba(34,40,49,0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      line-height: 1.3;
      pointer-events: none;          /* prevents blocking hover */
      transition: opacity 120ms ease, transform 120ms ease;
      transform-origin: left top;
      opacity: 0;
    }
    
    /* plugin uses .visible to show it */
    #vg-tooltip-element.visible {
      visibility: visible;
      opacity: 1;
      transform: translate3d(0,0,0) scale(1);
    }
    
    /* Provide a theme-specific wrapper class pattern the plugin may apply.
       The plugin may add "custom-theme" or "custom-theme-theme" depending on version.
       Include both to be safe. */
    #vg-tooltip-element.custom-theme,
    #vg-tooltip-element.custom-theme-theme,
    .custom-theme,
    .custom-theme-theme {
      background: linear-gradient(180deg, #fffdf3 0%, #fef3c7 100%);
      color: #111;
      border-color: rgba(34,40,49,0.08);
    }
    
    /* Table layout used by plugin for key/value pairs */
    #vg-tooltip-element table {
      border-spacing: 0;
      width: 100%;
    }
    #vg-tooltip-element table tr { border: none; }
    #vg-tooltip-element table tr td { padding: 4px 6px; vertical-align: middle; }
    
    /* Key / value classes the plugin emits */
    #vg-tooltip-element table tr td.key,
    #vg-tooltip-element .key {
      text-align: left;               /* change to left so highlighted chip aligns well */
      font-weight: 700;
      color: #234a7a;                 /* deep stormy blue for keys */
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
        
    /* Value styling */
    #vg-tooltip-element table tr td.value,
    #vg-tooltip-element .value {
      color: #0b6aa6;                 /* clear blue for numeric/text values */
      font-weight: 600;
      text-align: right;
    }

    /* Page and container */
    html,body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; color:#111; }
    
    body {
      margin: 0;
      padding: 0;
      background-color: #e0e7ef; /* soft blue-gray background */
      background-repeat: repeat;
      background-size: auto;
      font-family: Helvetica, Arial, sans-serif;
      color: #111;
    }
    
    /* Outer poster container */
    .poster {
      max-width: 1100px;
      margin: 0 auto;
      padding: 56px 20px 40px; /* 56px top, 20px left/right, 40px bottom */
      background-color: #f4f7fb; /* light grey poster background */
      box-shadow: 0 0 40px rgba(0,0,0,0.1);
      border-radius: 12px;
    }

    /* Inner content layout */
    .page {
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    /* Main page title */
    .page-title {
      font-size: 36px;
      font-weight: 700;
      color: #1f2a44; /* deep stormy blue */
      margin-bottom: 8px;
      text-align: center;
    }
    
    /* Subtitle under title */
    .page-subtitle {
      font-size: 20px;
      font-weight: 400;
      color: #4b5d7e; /* muted steel blue */
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Intro paragraph with narrow width and line breaks */
    .intro-paragraph {
      max-width: 700px;
      margin: 0 auto 32px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      text-align: center;
    }
    
    /* Highlighted words */
    .highlight {
      color: #e07b39; /* weathered orange */
      font-weight: 600;
    }

    /* Each viz card */
    .viz-card { 
      display:block; 
      margin-left:auto; 
      margin-right:auto; 
      max-width:1200px; 
    }

    .viz-title {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50; /* stormy navy */
      margin: 0 0 6px 0;
      text-align: left;
    }
    
    .viz-sub {
      font-size: 14px;
      color: #5c6e8c; /* steel blue-gray */
      margin: 0 0 16px 0;
      text-align: left;
    }

    /* Container */
    .viz-embed { position: relative; }
    
    /* Overlay SVG for leader lines (on top of canvas/svg) */
    .viz-embed .annotation-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }
    
    /* HTML annotation boxes: hug content, allow wrapping, standout font */
    .annotation-box {
      position: absolute;
      display: inline-block;           /* hug content width */
      transform: translate(0, 0);
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(34,40,49,0.08);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      font-family: "Merriweather", Georgia, "Times New Roman", serif; /* standout serif */
      font-size: 14px;
      color: #1f2a44;
      max-width: 320px;               /* max width before wrapping */
      white-space: normal;            /* allow wrapping */
      line-height: 1.25;
      pointer-events: auto;
      z-index: 9999;
    }
    
    /* label element inside the box — keep bolder weight if desired */
    .annotation-box .annotation-label {
      font-weight: 700;
      letter-spacing: -0.2px;
      color: #123047;
    }
    
    /* if you ever want a smaller secondary line, leave this in place (not used now) */
    .annotation-box .caption {
      display: block;
      margin-top: 6px;
      color: #55607a;
      font-size: 12px;
      font-weight: 500;
    }
    
    /* marker and line unchanged */
    .annotation-marker { fill: #e07b39; stroke: #fff; stroke-width: 1.5px; }
    .annotation-line { stroke: #e07b39; stroke-width: 1.6px; stroke-linecap: round; opacity: 0.95; }

    /* Row for side-by-side maps (dynamic) */
    .row { display:flex; gap:16px; align-items:flex-start; justify-content:center; }
    .col { flex:1; min-width:280px; max-width:620px; }

    /* Small responsive tweaks */
    @media (max-width: 900px) {
      .row { flex-direction: column; }
    }

    /* container that centers the chart+legend group */
    .viz-legend-wrapper { display: flex; justify-content: center; padding: 12px 0; }
    
    /* row holding chart and legend */
    /* STACK the two maps vertically in the left column */
    .viz-left {
      flex: 0 1 auto;
      min-width: 320px;
      max-width: 760px;        /* match other viz widths so left edge lines up */
      display: block;
    }

    .legend-right { flex: 0 0 auto; display: flex; align-items: flex-start; margin-left: 12px; }
    
    /* legend box styling */
    .size-legend {
      padding: 8px 12px;
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(34,40,49,0.08);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      color: #1f2a44;
      pointer-events: auto;
    }
    
    /* legend title */
    .size-legend .legend-title { font-weight: 700; margin-bottom: 6px; }
    
    /* responsive: stack on narrow screens */
    @media (max-width: 880px) {
      .viz-legend-wrapper { flex-direction: column; align-items: center; }
      .legend-right { margin-left: 0; margin-top: 12px; }
    }

    /* Scoped rules for the stacked maps group only */
    .map-stack-left {
      flex: 0 1 auto;
      min-width: 320px;
      max-width: 760px;      /* tune to match other viz group width */
      display: block;
    }
    
    /* stack the two maps vertically and keep full width of the left column */
    .map-stack-left .map-stack-item {
      margin-bottom: 18px;
      width: 100%;
      box-sizing: border-box;
    }
    
    /* make embedded canvases use the exact left-column width */
    .map-stack-left .viz-embed {
      width: 760px;          /* keep same left-edge alignment as other visualisations */
      max-width: 100%;
    }
    
  </style>
</head>
<body>
  <div class="poster">
    <div class="page">
      <h1 class="page-title">Tornadoes from the United States to Australia</h1>
      <h2 class="page-subtitle">
        When you think about tornadoes, you likely think about America.<br/>
        But Australia experiences <span class="highlight">around 100 tornadoes</span> a year.
      </h2>
      
      <p class="intro-paragraph">
        Tornadoes are one of the most <span class="highlight">violent</span> weather phenomena.<br/>
        They form under specific conditions: instability, moisture, and a lifting mechanism.<br/>
        Australia’s geography and climate make it <span class="highlight">ripe for severe storms</span>.<br/>
        Despite lower frequency than the U.S., tornadoes here can<br/>
        be <span class="highlight">just as destructive</span>.<br/>
        This page explores their patterns, strength, and impact.
      </p>

      <p class="intro-paragraph">
        Using the map below, inspect the locations where<br/>
        tornadoes are most common across Australia. 
      </p>
  
      <!-- 1) tornado_density_across_australia -->
      <section class="viz-card">
        <h3 class="viz-title">Tornado Density Across Australia between 1900 and 2025</h3>
        <p class="viz-sub">Aggregated by 3 degree bins and scaled by frequency.</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-tornado-density" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="tornado-size-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Tornado count</div>
              <svg id="tornado-size-legend-svg" width="260" height="80" role="img" aria-label="Tornado count legend"></svg>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        From the above map we can see that much of<br/>
        Australia experiences <span class="highlight">tornadoes</span>. The Bureau of Metereology (BOM)<br/>
        has a repository dedicated to <span class="highlight">severe weather</span>. Using this<br/>
        we can see how prevelant tornadoes are in<br/>
        comparison to other weather events.
      </p>
  
      <!-- 2) severe_weather_proportions_per_state -->
      <section class="viz-card">
        <h3 class="viz-title">Severe weather distribution between 1900 and 2025 by State</h3>
        <p class="viz-sub">ACT was excluded due to its small data size.</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-severe-proportions" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="severe-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Severe weather</div>
              <svg id="severe-legend-svg" width="200" height="140" role="img" aria-label="Severe weather legend"></svg>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        The <span class="highlight">Fujita rating</span> measures tornado strength.<br/>
        It was proposed in 1971 by Dr. Tetsuya Fujita.<br/>
        Dr. Fujita worked at the University of Chicago.<br/>
        Much research into severe storms focuses in the United States.<br/>
        The United States experiences a large number of <span class="highlight">tornadoes</span>.<br/>
        Tornadoes are unpredictable and difficult to study.<br/>
        Dr. Fujita proposed using a destruction scale to infer winds.<br/>
        For example, destroying mobile homes requires winds above 180 km/h.<br/>
        If mobile homes are destroyed, winds must have reached that magnitude.<br/>
        Tornadoes are broadly categorised on the F0 to F5 scale.<br/>
        In 2007 the <span class="highlight">Enhanced Fujita</span> scale was introduced.<br/>
        The Enhanced Fujita refined the damage rating categories.
      </p>
  
      <!-- 3+4) dynamic maps row: Australian and US maps (vertically placed) -->
      <section class="viz-card">
        <h3 class="viz-title">Tornadoes by Fujita rating — Australia and U.S. between 2010-2025</h3>
        <p class="viz-sub">Values are colour coded by Fujita rating</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left map-stack-left">
            <!-- stacked maps (vertical) -->
            <div id="aus-chart" class="viz-embed map-stack-item"></div>
            <div id="us-chart"  class="viz-embed map-stack-item"></div>
          </div>
      
          <div class="legend-right">
            <!-- reuse the same legend container pattern used previously -->
            <div id="combined-rating-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Fujita rating</div>
              <div id="legend-checkboxes"></div>
            </div>
          </div>
        </div>
      </section>
  
      <!-- 5) fastest_australian_tornadoes -->
      <section class="viz-card">
        <p class="viz-sub">As noted before. Wind speeds are estimated based on damage. When the BOM is surveying tornado damage, they estimate the associated wind strength. Use the time sliders in the below visualisation to
        see the fastest tornadoes in a given period.</p>
        <div id="viz-fastest-aus" class="viz-embed"></div>
      </section>
  
      <p>Tornadoes are very seasonal events. They require certain conditions to occur, such as a lifting mechanism, a moist atmosphere, and also conditional instability. Because of this, Spring is the most common season to 
      see tornadoes, although they can happen at any time of the year. View below the distribution of tornadoes across months in Australia - a Southern Hemisphere country - and the United States - a Northern Hemisphere country.</p>
  
      <!-- 6) tornadoes_by_month_aus_vs_us -->
      <section class="viz-card">
        <h3 class="viz-title">Tornadoes by month — Australia vs U.S.</h3>
        <div id="viz-by-month" class="viz-embed"></div>
      </section>
  
      <p>With wind speeds high enough to shred a well built house off of its foundations, tornadoes sadly have killed many people. See below a chart of some of the deadliest tornadoes of all time.</p>
  
      <!-- 7) deadliest_tornadoes_bubble_chart -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes — bubble chart</h3>
        <div id="viz-deadliest-bubble" class="viz-embed"></div>
      </section>
  
      <p>See the general locations of the deadliest tornadoes visualised on a map.</p>
  
      <!-- 8) deadliest_tornadoes_on_a_map -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes on a map</h3>
        <div id="viz-deadliest-map" class="viz-embed"></div>
      </section>
  
      <p>Wind shear is an important requirement for supercell development which is the type of thunderstorm that can produce a tornado. The wind needs to change in direction and magnitude with height. The El Reno 2013 tornado 
      was one of the largest tornadoes of all time. Look at the wind values across that day and note the curved shape in the last reading that was taken slightly after the tornado developed. This indicates rotation.</p>
  
      <!-- 9) first two el_reno_hodographs -->
      <section class="viz-card">
        <h3 class="viz-title">El Reno hodographs</h3>
        <div id="viz-hodographs_first_two" class="viz-embed"></div>
      </section>
  
      <!-- 10) second two el_reno_hodographs -->
      <section class="viz-card">
        <div id="viz-hodographs_second_two" class="viz-embed"></div>
      </section>
      
      <p>In conclusion, Australia has had its fair share of tornadoes and severe weather in general. However, the United States remains the capital of tornadoes.</p>
    </div>
  </div>

  <script>
    // ------------------------
    // Configuration
    // ------------------------

    // JSON spec filenames placed beside index.html in the same repo/folder
    const specs = {
      tornadoDensity: "tornado_density_across_australia.json",
      severeProportions: "severe_weather_proportions_per_state.json",
      fastestAus: "fastest_australian_tornadoes.json",
      byMonth: "tornadoes_by_month_aus_vs_us.json",
      deadliestBubble: "deadliest_tornadoes_bubble_chart.json",
      deadliestMap: "deadliest_tornadoes_on_a_map.json",
      firstTwoHodographs: "el_reno_first_two_hodographs.json",
      secondTwoHodographs: "el_reno_second_two_hodographs.json"
    };

    // CSV / topo repo used for dynamic maps (the repo you used previously)
    // If you want to change the repo, update this base path.
    const csvRepoBase = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/";

    // Patterns and topo files (update repo path if needed)
    const ausCsvPattern = csvRepoBase + "Tornado_F{R}_2010_2024_Australia.csv";
    const usCsvPattern  = csvRepoBase + "Tornado_F{R}_2010_2024_America.csv";

    const ausBaseTopo = csvRepoBase + "australia.json";
    const ausGraticules = csvRepoBase + "10_degree_graticules_for_australia.json";

    const usBaseTopo = csvRepoBase + "mainland_united_states.json";
    const usGraticules = csvRepoBase + "10_degree_graticules_for_united_states.json";

    // Fujita rating colours and list (initial selection: all)
    const ratingColors = {
      "F0": "#999999",
      "F1": "#E69F00",
      "F2": "#56B4E9",
      "F3": "#009E73",
      "F4": "#F0E442",
      "F5": "#984ea3"
    };
    const ratings = ["F0","F1","F2","F3","F4","F5"];
    let selectedRatings = new Set(ratings);

    // Latitude/longitude field names in the CSVs
    const ausLatField = "Latitude";
    const ausLonField = "Longitude";
    const usLatField = "BEGIN_LAT";
    const usLonField = "BEGIN_LON";

    // ------------------------
    // Helpers
    // ------------------------

    async function embedSpec(target, urlOrSpec) {
      try {
        await vegaEmbed(target, urlOrSpec, { 
          actions: false, 
          renderer: "canvas",
          tooltip: { 
            theme: 'custom',
            disableDefaultStyle: true
          }
        });
      } catch (err) {
        document.querySelector(target).innerHTML = "<div style='padding:12px;color:#900;'>Failed to render: " + (err.message || err) + "</div>";
        console.error("Embed error", err);
      }
    }

    async function fetchCsv(url) {
      try {
        const r = await fetch(url);
        if (!r.ok) return [];
        const text = await r.text();
        const lines = text.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const cols = lines[0].split(",");
        const rows = [];
        for (let i=1;i<lines.length;i++){
          const vals = lines[i].split(",");
          const obj = {};
          for (let j=0;j<cols.length;j++){
            obj[cols[j]] = vals[j] !== undefined ? vals[j] : "";
          }
          rows.push(obj);
        }
        return rows;
      } catch (e) {
        console.warn("CSV fetch failed", url, e);
        return [];
      }
    }

    // ------------------------
    // Creating legends 
    // ------------------------

    function drawTornadoSizeLegend(containerId = "tornado-size-legend-svg") {
      const domain = [1, 160];
      const rangeArea = [50, 800]; // same as Vega-Lite size scale (area in px^2)
      const counts = [150, 100, 30, 1]; // draw largest first (top) — change order if you prefer
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // helpers
      const areaForCount = c => {
        const t = (c - domain[0]) / (domain[1] - domain[0]);
        return rangeArea[0] + t * (rangeArea[1] - rangeArea[0]);
      };
      const radiusForArea = a => Math.sqrt(a / Math.PI);
    
      // clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      // layout params
      const paddingLeft = 12;
      const paddingTop = 12;
      const itemGap = 12;         // vertical gap between items
      const labelGap = 8;         // horizontal gap between circle and label
      const labelFontSize = 12;
    
      // compute radii and max width needed
      const radii = counts.map(c => radiusForArea(areaForCount(c)));
      const maxR = Math.max(...radii);
      const circleColWidth = Math.ceil(2 * maxR); // column reserved for circle diameter
      const labelColWidth = 70;                    // reserve for labels (adjust if needed)
    
      // initial positions
      let y = paddingTop;
    
      counts.forEach((c, i) => {
        const r = radii[i];
        const cx = paddingLeft + maxR;           // center circles in left column
        const cy = y + r;
    
        // circle
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", cx);
        circ.setAttribute("cy", cy);
        circ.setAttribute("r", r);
        circ.setAttribute("fill", "#0072B2");
        circ.setAttribute("fill-opacity", "0.85");
        circ.setAttribute("stroke", "#fff");
        circ.setAttribute("stroke-width", "1");
        svg.appendChild(circ);
    
        // label to the right of circle
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + circleColWidth + labelGap);
        label.setAttribute("y", cy + (labelFontSize / 3)); // vertically align text near center
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.textContent = String(c);
        svg.appendChild(label);
    
        // advance y for next item: circle diameter + gap
        y += Math.ceil(2 * r + itemGap);
      });
    
      // finalize svg size
      const totalWidth = paddingLeft + circleColWidth + labelGap + labelColWidth + 12;
      const totalHeight = y + 8;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function drawSevereLegendVertical(containerId = "severe-legend-svg") {
      // color mapping (matches your glyph colors)
      const items = [
        { key: "rain_mentions", label: "Rain", color: "#0072B2" },
        { key: "hail_mentions", label: "Hail", color: "#009E73" },
        { key: "tornado_mentions", label: "Tornado", color: "#D55E00" }
      ];
    
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // layout params chosen to match visual footprint of the tornado vertical legend
      const paddingLeft = 12;
      const paddingTop = 12;
      const swatchSize = 18;    // square swatch size
      const itemGap = 14;       // vertical gap between items
      const labelGap = 10;      // horizontal gap between swatch and label
      const labelFontSize = 12;
    
      // clear existing content
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      let y = paddingTop;
    
      items.forEach((it, i) => {
        // swatch (rounded rect)
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", paddingLeft);
        rect.setAttribute("y", y);
        rect.setAttribute("width", swatchSize);
        rect.setAttribute("height", swatchSize);
        rect.setAttribute("rx", 3);
        rect.setAttribute("ry", 3);
        rect.setAttribute("fill", it.color);
        rect.setAttribute("stroke", "#fff");
        rect.setAttribute("stroke-width", "1");
        svg.appendChild(rect);
    
        // label text
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + swatchSize + labelGap);
        label.setAttribute("y", y + swatchSize - 4);
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.setAttribute("class", "severe-legend-swatch-label");
        label.textContent = it.label;
        svg.appendChild(label);
    
        y += swatchSize + itemGap;
      });
    
      const totalWidth = paddingLeft + swatchSize + labelGap + 80;
      const totalHeight = y + 6;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }
    
    // ------------------------
    // Adding annotations
    // ------------------------

    async function embedWithHtmlAnnotations(target, specUrlOrObject, options = {}) {
      const projOpts = Object.assign({
        type: "mercator",
        center: [134, -28],
        scale: 850
      }, options.projection || {});
    
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = {
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      };
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
    
      if (view && typeof view.runAsync === "function") {
        await view.runAsync();
      }
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      // create/replace overlay SVG
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.setAttribute("preserveAspectRatio", "xMinYMin meet");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function makeProjection(width, height) {
        const vw = (view && typeof view.width === "function") ? view.width() : width;
        const vh = (view && typeof view.height === "function") ? view.height() : height;
        const geo = (typeof d3 !== "undefined" && typeof d3.geoMercator === "function") ? d3 : null;
        if (!geo) throw new Error("d3.geoMercator not available; include d3 (e.g. https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js)");
        return geo.geoMercator().center(projOpts.center).scale(projOpts.scale).translate([vw / 2, vh / 2]);
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        const proj = makeProjection(width, height);
        function projectPoint(lon, lat) {
          const p = proj([lon, lat]);
          return { x: p[0], y: p[1] };
        }
    
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
        // First create boxes so we can measure them for line endpoints
        const createdBoxes = annotations.map(a => {
          // compute box pixel position from lon/lat
          const boxLon = (a.boxLonLat && typeof a.boxLonLat.lon === "number") ? a.boxLonLat.lon : (a.src && a.src.lon);
          const boxLat = (a.boxLonLat && typeof a.boxLonLat.lat === "number") ? a.boxLonLat.lat : (a.src && a.src.lat);
          if (typeof boxLon !== "number" || typeof boxLat !== "number") return null;
          const boxPx = projectPoint(boxLon, boxLat);
    
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
    
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
    
          let left = Math.round(boxPx.x + container.scrollLeft + nudgeX);
          let top  = Math.round(boxPx.y + container.scrollTop + nudgeY);
    
          const containerRect = container.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const margin = 8;
          if (left + margin + boxMaxWidth > containerRect.width) left = Math.max(margin, containerRect.width - boxMaxWidth - margin);
          if (left < margin) left = margin;
          if (top < margin) top = margin;
          if (top > containerRect.height - 40) top = containerRect.height - 40;
    
          div.style.left = left + "px";
          div.style.top  = top + "px";
    
          container.appendChild(div);
    
          // return data needed for line calculation
          return {
            a,
            div,
            left,
            top,
            width: Math.min(boxMaxWidth, div.getBoundingClientRect().width),
            height: div.getBoundingClientRect().height,
            anchorPx: boxPx
          };
        }).filter(Boolean);
    
        // Draw leader lines connecting source to nearest point on the box rectangle
        createdBoxes.forEach(c => {
          const a = c.a;
          if (!a.leader || !a.src) return;
    
          const srcPx = projectPoint(a.src.lon, a.src.lat);
    
          // box rect in container coordinates
          const boxRect = {
            x1: c.left,
            y1: c.top,
            x2: c.left + c.width,
            y2: c.top + c.height
          };
    
          // find closest point on rect to srcPx
          const clamp = (val, mn, mx) => Math.max(mn, Math.min(mx, val));
          const closestX = clamp(srcPx.x, boxRect.x1, boxRect.x2);
          const closestY = clamp(srcPx.y, boxRect.y1, boxRect.y2);
    
          // if src is diagonally outside, nearest point may be corner — we already handle via clamp
          // draw SVG line from src to that closest point
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", srcPx.x);
          line.setAttribute("y1", srcPx.y);
          line.setAttribute("x2", closestX);
          line.setAttribute("y2", closestY);
          line.setAttribute("class", "annotation-line");
          line.setAttribute("stroke", a.lineColor || "#e07b39");
          line.setAttribute("stroke-width", (a.lineWidth || 1.6).toString());
          line.setAttribute("stroke-linecap", "round");
          overlay.appendChild(line);
        });
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on window + container resize
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }

    // ------------------------
    // Dynamic maps (Australia and US) logic
    // ------------------------

    // Build legend/toggles into the right-column container
    function buildCombinedLegend() {
      const container = document.getElementById("legend-checkboxes");
      container.innerHTML = "";
      ratings.forEach(r => {
        const item = document.createElement("div");
        item.className = "legend-item";
        item.dataset.rating = r;
    
        // checkbox
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = true;
        cb.value = r;
        cb.setAttribute("aria-label", r + " toggle");
        cb.addEventListener("change", onLegendToggle);
    
        // colored swatch (circle)
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = ratingColors[r];
    
        // label
        const lbl = document.createElement("span");
        lbl.className = "legend-label";
        lbl.textContent = r;
    
        // click on whole item toggles checkbox (but not when clicking the checkbox itself)
        item.addEventListener("click", (e) => {
          if (e.target.tagName.toLowerCase() === "input") return;
          cb.checked = !cb.checked;
          cb.dispatchEvent(new Event("change", { bubbles: true }));
        });
    
        item.appendChild(cb);
        item.appendChild(sw);
        item.appendChild(lbl);
        container.appendChild(item);
      });
    }

    function onLegendToggle(e) {
      const rating = e.target.value;
      const checked = e.target.checked;
      const item = e.target.closest(".legend-item");
      if (!item) return;
      if (!checked) {
        selectedRatings.delete(rating);
        item.classList.add("disabled");
      } else {
        selectedRatings.add(rating);
        item.classList.remove("disabled");
      }
      renderMaps(); // re-render maps with updated selectedRatings
    }

    async function renderMaps() {
      // build base layers
      const ausLayers = [
        {
          data: { url: ausBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: ausGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      const usLayers = [
        {
          data: { url: usBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: usGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      // gather per-rating point layers (only for selected ratings)
      for (const r of ratings) {
        if (!selectedRatings.has(r)) continue;

        const ausUrl = ausCsvPattern.replace("{R}", r.slice(1));
        const usUrl  = usCsvPattern.replace("{R}", r.slice(1));

        // fetch CSVs (graceful if missing)
        const [ausRows, usRows] = await Promise.all([fetchCsv(ausUrl), fetchCsv(usUrl)]);

        const ausValues = ausRows.map(row => {
          const out = Object.assign({}, row);
          if (out[ausLatField] !== undefined) out[ausLatField] = parseFloat(out[ausLatField]);
          if (out[ausLonField] !== undefined) out[ausLonField] = parseFloat(out[ausLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        const usValues = usRows.map(row => {
          const out = Object.assign({}, row);
          if (out[usLatField] !== undefined) out[usLatField] = parseFloat(out[usLatField]);
          if (out[usLonField] !== undefined) out[usLonField] = parseFloat(out[usLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        // push a point layer for this rating
        ausLayers.push({
          data: { values: ausValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: ausLonField, type: "quantitative" },
            latitude: { field: ausLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });

        usLayers.push({
          data: { values: usValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: usLonField, type: "quantitative" },
            latitude: { field: usLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
      } // end per-rating loop

      // Construct final specs
      const ausSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 800,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [134, -25], scale: 850 },
        layer: ausLayers,
        config: { view: { stroke: null } }
      };

      const usSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 800,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [-98, 38], scale: 850 },
        layer: usLayers,
        config: { view: { stroke: null } }
      };
      
      document.getElementById("aus-chart").innerHTML = "";
      document.getElementById("us-chart").innerHTML = "";
      
      // set spec widths consistent with CSS viz-left width (760)
      ausSpec.width = 760;
      usSpec.width = 760;
      
      // embed with same options you had
      await vegaEmbed("#aus-chart", ausSpec, { 
        actions: false, 
        renderer: "canvas", 
        tooltip: { theme: 'custom', disableDefaultStyle: true } 
      });
      await vegaEmbed("#us-chart", usSpec, { 
        actions: false, 
        renderer: "canvas", 
        tooltip: { theme: 'custom', disableDefaultStyle: true } 
      });
    }

    // ------------------------
    // Initialization: embed static specs and start dynamic maps
    // ------------------------
    async function init() {
    buildCombinedLegend();
    renderMaps();

      // Embed static JSON specs (they should be placed beside index.html or referenced by full path)
      
      await embedWithHtmlAnnotations("#viz-tornado-density", specs.tornadoDensity, { // embed the density visualisation and add annotations
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "victoria-hotspot",
            src: { lon: 129, lat: -39 },
            boxLonLat: { lon: 128, lat: -38 },
            label: "Southern Victoria experienced the\nmost recorded tornadoes",
            leader: false,
            nudgeX: -160,
            nudgeY: 20,
          },
          {
            id: "tropics-note",
            boxLonLat: { lon: 108, lat: -12 },
            label: "Tropics see more storms but\nfewer recorded tornadoes",
            leader: false
          }
        ]
      });

      drawTornadoSizeLegend();

      await embedSpec("#viz-severe-proportions", specs.severeProportions);
      drawSevereLegendVertical(); 
      
      await embedSpec("#viz-fastest-aus", specs.fastestAus);

      // other later static specs
      await embedSpec("#viz-by-month", specs.byMonth);
      await embedSpec("#viz-deadliest-bubble", specs.deadliestBubble);
      await embedSpec("#viz-deadliest-map", specs.deadliestMap);
      await embedSpec("#viz-hodographs_first_two", specs.firstTwoHodographs); 
      await embedSpec("#viz-hodographs_second_two", specs.secondTwoHodographs); 
    }

    // run
    init();
  </script>
</body>
</html>
</body>
</html>
