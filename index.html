<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Severe Weather Visualisations</title>

  <!-- Vega / Vega-Lite / Vega-Embed -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-tooltip@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script> <!-- we use this to calculate projections and ensure annotations remain in the correct position -->

  <style>
    /* Basic tooltip element and visibility behavior (matches plugin expectations) */
    #vg-tooltip-element {
      visibility: hidden;
      position: fixed;
      z-index: 9999;
      padding: 10px 12px;
      max-width: 360px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.12);
      border: 1px solid rgba(34,40,49,0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      line-height: 1.3;
      pointer-events: none;          /* prevents blocking hover */
      transition: opacity 120ms ease, transform 120ms ease;
      transform-origin: left top;
      opacity: 0;
    }
    
    /* plugin uses .visible to show it */
    #vg-tooltip-element.visible {
      visibility: visible;
      opacity: 1;
      transform: translate3d(0,0,0) scale(1);
    }
    
    /* Provide a theme-specific wrapper class pattern the plugin may apply.
       The plugin may add "custom-theme" or "custom-theme-theme" depending on version.
       Include both to be safe. */
    #vg-tooltip-element.custom-theme,
    #vg-tooltip-element.custom-theme-theme,
    .custom-theme,
    .custom-theme-theme {
      background: linear-gradient(180deg, #fffdf3 0%, #fef3c7 100%);
      color: #111;
      border-color: rgba(34,40,49,0.08);
    }
    
    /* Table layout used by plugin for key/value pairs */
    #vg-tooltip-element table {
      border-spacing: 0;
      width: 100%;
    }
    #vg-tooltip-element table tr { border: none; }
    #vg-tooltip-element table tr td { padding: 4px 6px; vertical-align: middle; }
    
    /* Key / value classes the plugin emits */
    #vg-tooltip-element table tr td.key,
    #vg-tooltip-element .key {
      text-align: left;               /* change to left so highlighted chip aligns well */
      font-weight: 700;
      color: #234a7a;                 /* deep stormy blue for keys */
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
        
    /* Value styling */
    #vg-tooltip-element table tr td.value,
    #vg-tooltip-element .value {
      color: #0b6aa6;                 /* clear blue for numeric/text values */
      font-weight: 600;
      text-align: right;
    }

    /* Page and container */
    html,body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; color:#111; }
    
    body {
      margin: 0;
      padding: 0;
      background-color: #e0e7ef; /* soft blue-gray background */
      background-repeat: repeat;
      background-size: auto;
      font-family: Helvetica, Arial, sans-serif;
      color: #111;
    }
    
    /* Outer poster container */
    .poster {
      max-width: 1440px;
      margin: 0 auto;
      padding: 40px 20px;
      background-color: #f4f7fb; /* light grey poster background */
      box-shadow: 0 0 40px rgba(0,0,0,0.1);
      border-radius: 12px;
    }

    /* Inner content layout */
    .page {
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    /* Main page title */
    .page-title {
      font-size: 36px;
      font-weight: 700;
      color: #1f2a44; /* deep stormy blue */
      margin-bottom: 8px;
      text-align: center;
    }
    
    /* Subtitle under title */
    .page-subtitle {
      font-size: 20px;
      font-weight: 400;
      color: #4b5d7e; /* muted steel blue */
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Intro paragraph with narrow width and line breaks */
    .intro-paragraph {
      max-width: 700px;
      margin: 0 auto 32px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      text-align: center;
    }
    
    /* Highlighted words */
    .highlight {
      color: #e07b39; /* weathered orange */
      font-weight: 600;
    }

    /* Each viz card */
    .viz-card { 
      display:block; 
      margin-left:auto; 
      margin-right:auto; 
      max-width:1200px; 
    }

    .viz-title {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50; /* stormy navy */
      margin: 0 0 6px 0;
      text-align: left;
    }
    
    .viz-sub {
      font-size: 14px;
      color: #5c6e8c; /* steel blue-gray */
      margin: 0 0 16px 0;
      text-align: left;
    }

    /* Container */
    .viz-embed { position: relative; }
    
    /* Overlay SVG for leader lines (on top of canvas/svg) */
    .viz-embed .annotation-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }
    
    /* HTML annotation boxes */
    .annotation-box {
      position: absolute;
      transform: translate(-0%, -0%); /* we'll adjust with left/top; tweak if needed */
      background: rgba(255,255,255,0.95);
      border: 1px solid rgba(34,40,49,0.08);
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      color: #1f2a44;
      max-width: 320px;
      pointer-events: auto; /* if you want interactive later */
      z-index: 9999;
    }
    
    /* smaller caption inside box */
    .annotation-box .caption {
      display: block;
      margin-top: 6px;
      color: #55607a;
      font-size: 12px;
      font-weight: 500;
    }
    
    /* styling for the highlighted source marker (drawn in overlay SVG) */
    .annotation-marker {
      fill: #e07b39;
      stroke: #fff;
      stroke-width: 1.5px;
      r: 8;
    }
    
    /* leader line styling in SVG */
    .annotation-line {
      stroke: #e07b39;
      stroke-width: 1.6px;
      stroke-linecap: round;
      opacity: 0.95;
    }

    /* Row for side-by-side maps (dynamic) */
    .row { display:flex; gap:16px; align-items:flex-start; justify-content:center; }
    .col { flex:1; min-width:280px; max-width:620px; }

    /* Small responsive tweaks */
    @media (max-width: 900px) {
      .row { flex-direction: column; }
    }

    /* Simple legend/controls area */
    #legend-checkboxes { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    .legend-item { display:flex; align-items:center; gap:8px; user-select:none; cursor:pointer; }
    .legend-item input { pointer-events:auto; }
    .swatch { width:16px; height:12px; border-radius:2px; display:inline-block; border:1px solid rgba(0,0,0,0.12); }
    .legend-label { font-size:13px; color:#222; }
    .legend-item.disabled { opacity:0.35; }
  </style>
</head>
<body>
  <div class="poster">
    <div class="page">
      <h1 class="page-title">Tornadoes from the United States to Australia</h1>
      <h2 class="page-subtitle">
        When you think about tornadoes, you likely think about America.
        But Australia experiences <span class="highlight">around 100 tornadoes</span> a year.
      </h2>
      
      <p class="intro-paragraph">
        Tornadoes are one of the most <span class="highlight">violent</span> weather phenomena.
        They form under specific conditions: instability, moisture, and a lifting mechanism.
        Australia’s geography and climate make it <span class="highlight">ripe for severe storms</span>.
        Despite lower frequency than the U.S., tornadoes here can be <span class="highlight">just as destructive</span>.
        This page explores their patterns, strength, and impact.
      </p>

      <p class="intro-paragraph">
        Using the map below, inspect the locations where
        tornadoes are most common across Australia. 
      </p>
  
      <!-- 1) tornado_density_across_australia -->
      <section class="viz-card">
        <h3 class="viz-title">Tornado Density Across Australia since 1900</h3>
        <p class="viz-sub">
          Aggregated by 3 degree bins and scaled by frequency.
        </p>
        <div id="viz-tornado-density" class="viz-embed"></div>
      </section>
  
      <!-- 2) severe_weather_proportions_per_state -->
      <section class="viz-card">
        <p class="viz-sub">Much of Australia's wild weather isn't tornado related. Look at the distribution of rain, hail and tornado events, reported by the Bureau of Metereology (BOM) for each state.
        ACT was excluded due to low amounts of data.</p>
        <div id="viz-severe-proportions" class="viz-embed"></div>
      </section>
  
      <p>The Fujita rating is a scale for measuring tornado strength. It was proposed in 1971 by Japanese-American meterologist Dr. Tetsuya Fujita at the University of Chicago. A lot of the research into severe storms
      has been focussed in the United States. This is because they experience a large number of tornadoes, compared to the rest of the world. It is hard to study tornadoes due to their unpredictable nature. Dr Fujita suggested
      the use of a destruction scale as a way to determine wind strength. For example, it is known winds above 180km/h are required to destroy mobile homes. This means that if mobile homes have been destroyed then the tornado
      must have had winds of this magnitude. Tornadoes are broadly categorised into F0-F5 ratings. In 2007 the Enhanced Fujita scale was introduced. This refined the damage rating categories.</p>
  
      <!-- 3+4) dynamic maps row: Australian and US maps (side-by-side) -->
      <section class="viz-card">
        <h3 class="viz-title">Tornadoes by Fujita rating — Australia and U.S.</h3>
        <p class="viz-sub">Dynamic maps generated from per-rating CSVs; toggle ratings using the checkboxes below. Inspect the locations that experienced the most tornadoes and the most severe tornadoes.</p>
  
        <!-- legend/checkboxes for rating toggles -->
        <div id="legend-checkboxes" style="margin-bottom:12px;"></div>
  
        <div class="row">
          <div id="aus-chart" class="col viz-embed"></div>
          <div id="us-chart"  class="col viz-embed"></div>
        </div>
      </section>
  
      <!-- 5) fastest_australian_tornadoes -->
      <section class="viz-card">
        <p class="viz-sub">As noted before. Wind speeds are estimated based on damage. When the BOM is surveying tornado damage, they estimate the associated wind strength. Use the time sliders in the below visualisation to
        see the fastest tornadoes in a given period.</p>
        <div id="viz-fastest-aus" class="viz-embed"></div>
      </section>
  
      <p>Tornadoes are very seasonal events. They require certain conditions to occur, such as a lifting mechanism, a moist atmosphere, and also conditional instability. Because of this, Spring is the most common season to 
      see tornadoes, although they can happen at any time of the year. View below the distribution of tornadoes across months in Australia - a Southern Hemisphere country - and the United States - a Northern Hemisphere country.</p>
  
      <!-- 6) tornadoes_by_month_aus_vs_us -->
      <section class="viz-card">
        <h3 class="viz-title">Tornadoes by month — Australia vs U.S.</h3>
        <div id="viz-by-month" class="viz-embed"></div>
      </section>
  
      <p>With wind speeds high enough to shred a well built house off of its foundations, tornadoes sadly have killed many people. See below a chart of some of the deadliest tornadoes of all time.</p>
  
      <!-- 7) deadliest_tornadoes_bubble_chart -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes — bubble chart</h3>
        <div id="viz-deadliest-bubble" class="viz-embed"></div>
      </section>
  
      <p>See the general locations of the deadliest tornadoes visualised on a map.</p>
  
      <!-- 8) deadliest_tornadoes_on_a_map -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes on a map</h3>
        <div id="viz-deadliest-map" class="viz-embed"></div>
      </section>
  
      <p>Wind shear is an important requirement for supercell development which is the type of thunderstorm that can produce a tornado. The wind needs to change in direction and magnitude with height. The El Reno 2013 tornado 
      was one of the largest tornadoes of all time. Look at the wind values across that day and note the curved shape in the last reading that was taken slightly after the tornado developed. This indicates rotation.</p>
  
      <!-- 9) first two el_reno_hodographs -->
      <section class="viz-card">
        <h3 class="viz-title">El Reno hodographs</h3>
        <div id="viz-hodographs_first_two" class="viz-embed"></div>
      </section>
  
      <!-- 10) second two el_reno_hodographs -->
      <section class="viz-card">
        <div id="viz-hodographs_second_two" class="viz-embed"></div>
      </section>
      
      <p>In conclusion, Australia has had its fair share of tornadoes and severe weather in general. However, the United States remains the capital of tornadoes.</p>
    </div>
  </div>

  <script>
    // ------------------------
    // Configuration
    // ------------------------

    // JSON spec filenames placed beside index.html in the same repo/folder
    const specs = {
      tornadoDensity: "tornado_density_across_australia.json",
      severeProportions: "severe_weather_proportions_per_state.json",
      fastestAus: "fastest_australian_tornadoes.json",
      byMonth: "tornadoes_by_month_aus_vs_us.json",
      deadliestBubble: "deadliest_tornadoes_bubble_chart.json",
      deadliestMap: "deadliest_tornadoes_on_a_map.json",
      firstTwoHodographs: "el_reno_first_two_hodographs.json",
      secondTwoHodographs: "el_reno_second_two_hodographs.json"
    };

    // CSV / topo repo used for dynamic maps (the repo you used previously)
    // If you want to change the repo, update this base path.
    const csvRepoBase = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/";

    // Patterns and topo files (update repo path if needed)
    const ausCsvPattern = csvRepoBase + "Tornado_F{R}_2010_2024_Australia.csv";
    const usCsvPattern  = csvRepoBase + "Tornado_F{R}_2010_2024_America.csv";

    const ausBaseTopo = csvRepoBase + "australia.json";
    const ausGraticules = csvRepoBase + "10_degree_graticules_for_australia.json";

    const usBaseTopo = csvRepoBase + "mainland_united_states.json";
    const usGraticules = csvRepoBase + "10_degree_graticules_for_united_states.json";

    // Fujita rating colours and list (initial selection: all)
    const ratingColors = {
      "F0": "#999999",
      "F1": "#E69F00",
      "F2": "#56B4E9",
      "F3": "#009E73",
      "F4": "#F0E442",
      "F5": "#984ea3"
    };
    const ratings = ["F0","F1","F2","F3","F4","F5"];
    let selectedRatings = new Set(ratings);

    // Latitude/longitude field names in the CSVs
    const ausLatField = "Latitude";
    const ausLonField = "Longitude";
    const usLatField = "BEGIN_LAT";
    const usLonField = "BEGIN_LON";

    // ------------------------
    // Helpers
    // ------------------------

    async function embedSpec(target, urlOrSpec) {
      try {
        await vegaEmbed(target, urlOrSpec, { 
          actions: false, 
          renderer: "canvas",
          tooltip: { 
            theme: 'custom',
            disableDefaultStyle: true
          }
        });
      } catch (err) {
        document.querySelector(target).innerHTML = "<div style='padding:12px;color:#900;'>Failed to render: " + (err.message || err) + "</div>";
        console.error("Embed error", err);
      }
    }

    async function fetchCsv(url) {
      try {
        const r = await fetch(url);
        if (!r.ok) return [];
        const text = await r.text();
        const lines = text.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const cols = lines[0].split(",");
        const rows = [];
        for (let i=1;i<lines.length;i++){
          const vals = lines[i].split(",");
          const obj = {};
          for (let j=0;j<cols.length;j++){
            obj[cols[j]] = vals[j] !== undefined ? vals[j] : "";
          }
          rows.push(obj);
        }
        return rows;
      } catch (e) {
        console.warn("CSV fetch failed", url, e);
        return [];
      }
    }

    // ------------------------
    // Tornado Density
    // ------------------------

    async function embedWithHtmlAnnotations(target, specUrlOrObject, options = {}) {
      // defaults to match your map spec
      const projOpts = Object.assign({
        type: "mercator",
        center: [134, -28],
        scale: 850
      }, options.projection || {});
    
      // annotations: source point + boxed label and standalone top-left box
      const annotations = options.annotations || [
        {
          id: "victoria-hotspot",
          src: { lon: 144, lat: -39 },        // map point to highlight
          boxLonLat: { lon: 128, lat: -38 }, // box anchor in lon/lat for bottom-left box
          label: "Southern Victoria experienced the most recorded tornadoes",
          caption: "Aggregated 1900–2024",
          leader: true
        },
        {
          id: "tropics-note",
          boxLonLat: { lon: 113, lat: -12 },
          label: "Tropics see more storms but fewer recorded tornadoes",
          caption: "Observation from reporting data",
          leader: false
        }
      ];
    
      // fetch or clone spec
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      // embed the spec as you normally do
      const embedOptions = {
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      };
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result.view; // not used for projection here, but kept if needed
    
      // prepare overlay elements inside container
      const container = document.querySelector(target);
      // ensure container exists
      if (!container) throw new Error("Embed target not found: " + target);
    
      // create overlay SVG if not present
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove(); // reset
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.setAttribute("preserveAspectRatio", "xMinYMin meet");
      container.appendChild(overlay);
    
      // create HTML boxes container (we'll append boxes)
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      // projection using d3-geo: must match Vega-Lite projection params
      // We'll set translate to [width/2, height/2] so center aligns to middle of embed
      function makeProjection(width, height) {
        const proj = d3.geoMercator()
          .center(projOpts.center)
          .scale(projOpts.scale)
          .translate([width / 2, height / 2]);
        return proj;
      }
    
      // function to (re)draw annotations
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        // set overlay svg size
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        const proj = makeProjection(width, height);
    
        // map lon/lat to pixels relative to the container top-left
        function projectPoint(lon, lat) {
          const p = proj([lon, lat]); // returns [x, y]
          return { x: p[0], y: p[1] };
        }
    
        // clear overlay children
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
    
        // draw markers, leader lines, and boxes
        annotations.forEach(a => {
          // if source point exists, project and draw a small circle/marker
          let srcPx = null;
          if (a.src) {
            srcPx = projectPoint(a.src.lon, a.src.lat);
            const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circ.setAttribute("cx", srcPx.x);
            circ.setAttribute("cy", srcPx.y);
            circ.setAttribute("r", 8);
            circ.setAttribute("class", "annotation-marker");
            circ.setAttribute("fill", "#e07b39");
            circ.setAttribute("stroke", "#ffffff");
            circ.setAttribute("stroke-width", "1.5");
            overlay.appendChild(circ);
          }
    
          // compute box pixel position from a.boxLonLat
          const boxLon = (a.boxLonLat && a.boxLonLat.lon) || (a.src && a.src.lon);
          const boxLat = (a.boxLonLat && a.boxLonLat.lat) || (a.src && a.src.lat);
          const boxPx = projectPoint(boxLon, boxLat);
    
          // draw leader line if requested and src exists
          if (a.leader && srcPx) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", srcPx.x);
            line.setAttribute("y1", srcPx.y);
            line.setAttribute("x2", boxPx.x);
            line.setAttribute("y2", boxPx.y);
            line.setAttribute("class", "annotation-line");
            overlay.appendChild(line);
          }
    
          // create HTML box and position it at boxPx
          const div = document.createElement("div");
          div.className = "annotation-box";
          div.setAttribute("data-annotation-id", a.id || "");
          // place box with its top-left at boxPx; you can adjust translate or offset here
          const left = Math.round(boxPx.x + container.scrollLeft);
          const top = Math.round(boxPx.y + container.scrollTop);
          div.style.left = left + "px";
          div.style.top = top + "px";
    
          // insert content
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.textContent = a.label || "";
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          // append box to container (on top of overlay)
          container.appendChild(div);
        });
      }
    
      // initial draw (run after a small delay to allow embed internals to layout)
      setTimeout(drawAnnotations, 120);
    
      // redraw on window resize so boxes reflow with container / page edits
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
    
      // return helpers in case you want to reproject or update annotations later
      return { result, drawAnnotations, annotations };
    }

    // ------------------------
    // Dynamic maps (Australia and US) logic
    // ------------------------

    function buildCombinedLegend() {
      const container = document.getElementById("legend-checkboxes");
      container.innerHTML = "";
      ratings.forEach(r => {
        const item = document.createElement("div");
        item.className = "legend-item";
        item.dataset.rating = r;

        // checkbox
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = true;
        cb.value = r;
        cb.setAttribute("aria-label", r + " toggle");
        cb.addEventListener("change", onLegendToggle);

        // swatch
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = ratingColors[r];

        // label
        const lbl = document.createElement("span");
        lbl.className = "legend-label";
        lbl.textContent = r;

        // click on whole item toggles checkbox
        item.addEventListener("click", (e) => {
          if (e.target.tagName.toLowerCase() === "input") return;
          cb.checked = !cb.checked;
          cb.dispatchEvent(new Event("change"));
        });

        item.appendChild(cb);
        item.appendChild(sw);
        item.appendChild(lbl);
        container.appendChild(item);
      });
    }

    function onLegendToggle(e) {
      const rating = e.target.value;
      const checked = e.target.checked;
      const item = e.target.closest(".legend-item");
      if (!checked) {
        selectedRatings.delete(rating);
        item.classList.add("disabled");
      } else {
        selectedRatings.add(rating);
        item.classList.remove("disabled");
      }
      renderMaps();
    }

    async function renderMaps() {
      // build base layers
      const ausLayers = [
        {
          data: { url: ausBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#e0e0e0", stroke: "white", strokeWidth: 1 }
        },
        {
          data: { url: ausGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      const usLayers = [
        {
          data: { url: usBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#e0e0e0", stroke: "white", strokeWidth: 1 }
        },
        {
          data: { url: usGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      // gather per-rating point layers (only for selected ratings)
      for (const r of ratings) {
        if (!selectedRatings.has(r)) continue;

        const ausUrl = ausCsvPattern.replace("{R}", r.slice(1));
        const usUrl  = usCsvPattern.replace("{R}", r.slice(1));

        // fetch CSVs (graceful if missing)
        const [ausRows, usRows] = await Promise.all([fetchCsv(ausUrl), fetchCsv(usUrl)]);

        const ausValues = ausRows.map(row => {
          const out = Object.assign({}, row);
          if (out[ausLatField] !== undefined) out[ausLatField] = parseFloat(out[ausLatField]);
          if (out[ausLonField] !== undefined) out[ausLonField] = parseFloat(out[ausLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        const usValues = usRows.map(row => {
          const out = Object.assign({}, row);
          if (out[usLatField] !== undefined) out[usLatField] = parseFloat(out[usLatField]);
          if (out[usLonField] !== undefined) out[usLonField] = parseFloat(out[usLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        // push a point layer for this rating
        ausLayers.push({
          data: { values: ausValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: ausLonField, type: "quantitative" },
            latitude: { field: ausLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });

        usLayers.push({
          data: { values: usValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: usLonField, type: "quantitative" },
            latitude: { field: usLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
      } // end per-rating loop

      // Construct final specs
      const ausSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 700,
        height: 540,
        background: "#c6dbef",
        projection: { type: "mercator", center: [134, -25], scale: 700 },
        title: { text: "Australian Tornadoes (2010–2024)", anchor: "start", fontSize: 16, font: "Helvetica", color: "#222", subtitle: "Color-coded by Fujita rating" },
        layer: ausLayers,
        config: { view: { stroke: null } }
      };

      const usSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 700,
        height: 540,
        background: "#c6dbef",
        projection: { type: "mercator", center: [-98, 38], scale: 700 },
        title: { text: "U.S. Tornadoes (2010–2024)", anchor: "start", fontSize: 16, font: "Helvetica", color: "#222", subtitle: "Color-coded by Fujita rating" },
        layer: usLayers,
        config: { view: { stroke: null } }
      };

      // embed into the two side-by-side containers
      document.getElementById("aus-chart").innerHTML = "";
      document.getElementById("us-chart").innerHTML = "";
      await vegaEmbed("#aus-chart", ausSpec, { actions: false, renderer: "canvas" });
      await vegaEmbed("#us-chart", usSpec, { actions: false, renderer: "canvas" });
    }

    // ------------------------
    // Initialization: embed static specs and start dynamic maps
    // ------------------------
    async function init() {
      // build legend toggles for dynamic maps
      buildCombinedLegend();

      // Embed static JSON specs (they should be placed beside index.html or referenced by full path)
      
      await embedWithHtmlAnnotations("#viz-tornado-density", specs.tornadoDensity, { // embed the density visualisation and add annotations
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "victoria-hotspot",
            src: { lon: 144, lat: -39 },
            boxLonLat: { lon: 128, lat: -38 },
            label: "Southern Victoria experienced the most recorded tornadoes",
            caption: "Aggregated 1900–2024",
            leader: true
          },
          {
            id: "tropics-note",
            boxLonLat: { lon: 113, lat: -12 },
            label: "Tropics see more storms but fewer recorded tornadoes",
            caption: "Observation from reporting data",
            leader: false
          }
        ]
      });

      await embedSpec("#viz-severe-proportions", specs.severeProportions);
      await embedSpec("#viz-fastest-aus", specs.fastestAus);

      // other later static specs
      await embedSpec("#viz-by-month", specs.byMonth);
      await embedSpec("#viz-deadliest-bubble", specs.deadliestBubble);
      await embedSpec("#viz-deadliest-map", specs.deadliestMap);
      await embedSpec("#viz-hodographs_first_two", specs.firstTwoHodographs); 
      await embedSpec("#viz-hodographs_second_two", specs.secondTwoHodographs); 

      // Render dynamic maps row (Australia + US)
      await renderMaps();
    }

    // run
    init();
  </script>
</body>
</html>
</body>
</html>
