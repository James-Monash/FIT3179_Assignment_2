<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Severe Weather Visualisations</title>

  <!-- Vega / Vega-Lite / Vega-Embed -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-tooltip@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script> <!-- we use this to calculate projections and ensure annotations remain in the correct position -->

  <style>
    /* Basic tooltip element and visibility behavior (matches plugin expectations) */
    #vg-tooltip-element {
      visibility: hidden;
      position: fixed;
      z-index: 9999;
      padding: 10px 12px;
      max-width: 360px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.12);
      border: 1px solid rgba(34,40,49,0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      line-height: 1.3;
      pointer-events: none;          /* prevents blocking hover */
      transition: opacity 120ms ease, transform 120ms ease;
      transform-origin: left top;
      opacity: 0;
    }
    
    /* plugin uses .visible to show it */
    #vg-tooltip-element.visible {
      visibility: visible;
      opacity: 1;
      transform: translate3d(0,0,0) scale(1);
    }
    
    /* Provide a theme-specific wrapper class pattern the plugin may apply.
       The plugin may add "custom-theme" or "custom-theme-theme" depending on version.
       Include both to be safe. */
    #vg-tooltip-element.custom-theme,
    #vg-tooltip-element.custom-theme-theme,
    .custom-theme,
    .custom-theme-theme {
      background: linear-gradient(180deg, #fffdf3 0%, #fef3c7 100%);
      color: #111;
      border-color: rgba(34,40,49,0.08);
    }
    
    /* Table layout used by plugin for key/value pairs */
    #vg-tooltip-element table {
      border-spacing: 0;
      width: 100%;
    }
    #vg-tooltip-element table tr { border: none; }
    #vg-tooltip-element table tr td { padding: 4px 6px; vertical-align: middle; }
    
    /* Key / value classes the plugin emits */
    #vg-tooltip-element table tr td.key,
    #vg-tooltip-element .key {
      text-align: left;               /* change to left so highlighted chip aligns well */
      font-weight: 700;
      color: #234a7a;                 /* deep stormy blue for keys */
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
        
    /* Value styling */
    #vg-tooltip-element table tr td.value,
    #vg-tooltip-element .value {
      color: #0b6aa6;                 /* clear blue for numeric/text values */
      font-weight: 600;
      text-align: right;
    }

    /* Page and container */
    html,body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; color:#111; }
    
    body {
      margin: 0;
      padding: 0;
      background-color: #e0e7ef; /* soft blue-gray background */
      background-repeat: repeat;
      background-size: auto;
      font-family: Helvetica, Arial, sans-serif;
      color: #111;
    }
    
    /* Outer poster container */
    .poster {
      max-width: 1100px;
      margin: 0 auto;
      padding-left: 40px; 
      padding-right: 20px; 
      padding-top: 56px; 
      padding-bottom: 40px; 
      background-color: #f4f7fb; /* light grey poster background */
      box-shadow: 0 0 40px rgba(0,0,0,0.1);
      border-radius: 12px;
    }

    /* Inner content layout */
    .page {
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    /* Image at the top of the page */
    .opening-image {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    
    .opening-img {
      max-width: 640px;
      width: 80%;
      height: auto;
      display: block;
      border-radius: 6px;
    }

    /* Main page title */
    .page-title {
      font-size: 36px;
      font-weight: 700;
      color: #1f2a44; /* deep stormy blue */
      margin-bottom: 8px;
      text-align: center;
    }
    
    /* Subtitle under title */
    .page-subtitle {
      font-size: 20px;
      font-weight: 400;
      color: #4b5d7e; /* muted steel blue */
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Intro paragraph with narrow width and line breaks */
    .intro-paragraph {
      max-width: 700px;
      margin: 0 auto 32px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      text-align: center;
    }
    
    /* Highlighted words */
    .highlight {
      color: #e07b39; /* weathered orange */
      font-weight: 600;
    }

    /* Each viz card */
    .viz-card {
      max-width: 1080px;
      margin-left: 1.5cm;
      margin-right: auto;
      position: relative;
    }
    
    .viz-title {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50; /* stormy navy */
      margin: 0 0 6px 0;
      text-align: left;
    }
    
    .viz-sub {
      font-size: 14px;
      color: #5c6e8c; /* steel blue-gray */
      margin: 0 0 16px 0;
      text-align: left;
    }

    /* Container */
    .viz-embed { position: relative; }
    
    /* Overlay SVG for leader lines (on top of canvas/svg) */
    .viz-embed .annotation-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }
    
    /* HTML annotation boxes: hug content, allow wrapping, standout font */
    .annotation-box {
      position: absolute;
      display: inline-block;           /* hug content width */
      transform: translate(0, 0);
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(34,40,49,0.08);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      font-family: "Merriweather", Georgia, "Times New Roman", serif; /* standout serif */
      font-size: 14px;
      color: #1f2a44;
      max-width: 320px;               /* max width before wrapping */
      white-space: normal;            /* allow wrapping */
      line-height: 1.25;
      pointer-events: auto;
      z-index: 9999;
    }
    
    /* label element inside the box — keep bolder weight if desired */
    .annotation-box .annotation-label {
      font-weight: 700;
      letter-spacing: -0.2px;
      color: #123047;
    }
    
    /* if you ever want a smaller secondary line, leave this in place (not used now) */
    .annotation-box .caption {
      display: block;
      margin-top: 6px;
      color: #55607a;
      font-size: 12px;
      font-weight: 500;
    }
    
    /* marker and line unchanged */
    .annotation-marker { fill: #e07b39; stroke: #fff; stroke-width: 1.5px; }
    .annotation-line { stroke: #e07b39; stroke-width: 1.6px; stroke-linecap: round; opacity: 0.95; }

    /* Row for side-by-side maps (dynamic) */
    .row { display:flex; gap:16px; align-items:flex-start; justify-content:center; }
    .col { flex:1; min-width:280px; max-width:620px; }

    /* Small responsive tweaks */
    @media (max-width: 900px) {
      .row { flex-direction: column; }
    }

    /* header block that matches viz-left width and centering */
    .viz-header { display:flex; justify-content:flex-start; margin-bottom:8px; }
    .viz-title-block { width:100%; max-width:840px; box-sizing:border-box; }
    .viz-title, .viz-sub { margin:0; padding:0; }

    /* container that centers the chart+legend group */
    .viz-legend-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 24px;              /* small gap between viz and legend */
      padding: 12px 0;
    }

    /* make the left viz container a positioned block that can be sized by embed */
    .viz-left {
      flex: 0 0 840px;        /* fixed viz width that matches your Vega width */
      max-width: 100%;
      position: relative;
      box-sizing: border-box;
    }
    
    /* Ensure embed fills the left column */
    .viz-left .viz-embed,
    .viz-embed {
      width: 100% !important;
      max-width: 100% !important;
      height: auto;
    }
    
    .legend-right { 
      position: static !important; 
      top: auto !important; 
      right: auto !important; 
      z-index: auto !important; 
    }
    
    /* Legend styling */
    .size-legend {
      padding: 8px 10px;
      background: rgba(255,255,255,0.96);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      border: 1px solid rgba(34,40,49,0.08);
      max-width: 300px;
    }
    
    /* responsive: stack on narrow screens */
    @media (max-width: 880px) {
      .viz-legend-wrapper { flex-direction: column; align-items: center; }
      .legend-right { margin-left: 0; margin-top: 12px; }
    }

    /* Scoped rules for the stacked maps group only */
    .map-stack-left {
      flex: 0 1 auto;
      min-width: 320px;
      max-width: 840px;      /* tune to match other viz group width */
      display: block;
    }
    
    /* stack the two maps vertically and keep full width of the left column */
    .map-stack-left .map-stack-item {
      margin-bottom: 18px;
      width: 100%;
      box-sizing: border-box;
    }
    
    /* make embedded canvases use the exact left-column width */
    .map-stack-left .viz-embed {
      width: 840px;          /* keep same left-edge alignment as other visualisations */
      max-width: 100%;
    }

    // ----------------------------
    // Country legend style
    // ----------------------------

    #country-legend-swatches,
    #deadliest-country-swatches {
      display: flex !important;
      flex-direction: column !important;
      gap: 6px !important;          /* same as fujita */
      margin-top: 8px !important;
      padding: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* Each row: mirror fujita row sizing and alignment */
    #country-legend-swatches .f-row,
    #deadliest-country-swatches .f-row {
      display: flex !important;
      align-items: center !important;
      gap: 8px !important;
      font-size: 13px !important;   /* same as fujita */
      color: #123047 !important;
      padding: 0 !important;
      min-height: 20px !important;
      box-sizing: border-box !important;
    }
    
    /* Swatch styling to match fujita look (rect-like) */
    #country-legend-swatches .swatch,
    #deadliest-country-swatches .swatch {
      width: 24px !important;
      height: 14px !important;
      border-radius: 3px !important;
      border: 1px solid rgba(0,0,0,0.08) !important;
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06) !important;
      margin-right: 0 !important;
      flex: 0 0 auto !important;
      display: inline-block !important;
    }
    
    /* Label weight and description style */
    #country-legend-swatches .f-label,
    #deadliest-country-swatches .f-label {
      flex: 0 0 auto !important;
      font-weight: 700 !important;
      font-family: Inter, sans-serif !important;
      line-height: 1 !important;
      color: inherit !important;
    }
    
    /* Optional small description class if you use it */
    #country-legend-swatches .f-desc,
    #deadliest-country-swatches .f-desc {
      color: #55607a !important;
      font-weight: 500 !important;
      margin-left: 6px !important;
      font-size: 13px !important;
    }
    
    // ----------------------------
    // Fujita rating legend styles
    // ----------------------------

    .fujita-legend {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
    }
    
    .fujita-legend .f-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #123047;
    }
    
    .fujita-legend .swatch {
      width: 24px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06);
      flex: 0 0 auto;
    }
    
    .fujita-legend .f-label {
      flex: 0 0 auto;
      font-weight: 700;
    }
    
    .fujita-legend .f-desc {
      color: #55607a;
      font-weight: 500;
      margin-left: 6px;
    }

    .legend-item.disabled { opacity: 0.45; }
    .legend-item .legend-checkbox { margin-right: 8px; }

    // ----------------------------
    // El Reno
    // ----------------------------
    
    /* Two-column layout for El Reno with shared-height centring */
    .el-reno-image-row { margin-bottom: 18px; }
    
    /* Grid with fixed left column and right column for chart+legend */
    .el-reno-two-col {
      display: grid;
      grid-template-columns: 320px 1fr;
      column-gap: 28px;
      align-items: center;
      box-sizing: border-box;
      width: 100%;
      max-width: 1080px;
      padding-left: 24px;
    }
    
    /* LEFT: text column — fill the shared visual height and centre contents */
    .el-reno-left {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 480px;     /* shared visual baseline = hodograph height */
      box-sizing: border-box;
    }
    .el-reno-left .el-reno-narrow { margin: 0; max-width: 40ch; text-align: center; line-height: 1.6; }
    
    /* RIGHT: hodograph container — same min-height so both columns share vertical centre */
    .el-reno-right {
      position: relative;
      display: flex;
      align-items: center;   /* centre chart vertically inside the right column */
      justify-content: flex-start;
      min-height: 480px;     /* must match left min-height */
      box-sizing: border-box;
    }
    
    /* Ensure hodograph embed is exact size */
    #viz-el-reno-hodograph.viz-embed,
    #viz-el-reno-hodograph.viz-embed > svg,
    #viz-el-reno-hodograph.viz-embed > div,
    #viz-el-reno-hodograph.viz-embed iframe {
      display: block !important;
      width: 480px !important;
      height: 480px !important;
      margin: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* Legend: absolutely positioned relative to .el-reno-right so it doesn't affect flow */
    .el-reno-right .el-reno-legend-box {
      position: absolute;
      left: calc(480px + 12px); /* place to the right of the chart, adjust gap by changing 12px */
      top: 0;                   /* aligns top with chart top */
      width: 112px;
      padding: 6px;
      background: rgba(255,255,255,0.98);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      border: 1px solid rgba(34,40,49,0.08);
      box-sizing: border-box;
      z-index: 50;
    }
    .el-reno-right .el-reno-legend-box .legend-title { font-size: 12px; font-weight: 700; margin-bottom: 6px; }
    .el-reno-right .el-reno-legend-box #el-reno-order-swatches,
    .el-reno-right .el-reno-legend-box #el-reno-order-swatches svg {
      width: 64px !important; height: auto !important; display: block !important;
    }
    
    /* Remove stray margins inside the two-col so centres align */
    .el-reno-two-col * { margin: 0; padding: 0; box-sizing: border-box; }
    
    /* Responsive fallback: stack on narrow screens */
    @media (max-width: 980px) {
      .el-reno-two-col { display: block; padding-left: 0; }
      .el-reno-left, .el-reno-right { min-height: auto; padding-left: 0; }
      #viz-el-reno-hodograph.viz-embed,
      #viz-el-reno-hodograph.viz-embed > svg,
      #viz-el-reno-hodograph.viz-embed > div,
      #viz-el-reno-hodograph.viz-embed iframe { width: 100% !important; height: auto !important; }
      .el-reno-right .el-reno-legend-box { position: static; left: auto; top: auto; width: 100%; margin-top: 8px; }
    }
  
  </style>
</head>
<body>
  <div class="poster">
    <div class="page">
      
      <div class="opening-image" aria-hidden="false" role="img" aria-label="Tornado illustration">
        <img src="tornado.jpg" alt="Tornado" class="opening-img" />
      </div>
      
      <h1 class="page-title">Tornadoes from the United States to Australia</h1>
      <h2 class="page-subtitle">
        When you think about tornadoes, you likely think about America.<br/>
        But Australia experiences <span class="highlight">around 100 tornadoes</span> a year.
      </h2>
      
      <p class="intro-paragraph">
        Tornadoes are one of the most <span class="highlight">violent</span> weather phenomena.<br/>
        They form under specific conditions: instability, moisture, and a lifting mechanism.<br/>
        Australia’s geography and climate make it <span class="highlight">ripe for severe storms</span>.<br/>
        Despite lower frequency than the U.S., tornadoes here can<br/>
        be <span class="highlight">just as destructive</span>.<br/>
        This page explores their patterns, strength, and impact.
      </p>

      <p class="intro-paragraph">
        Using the map below, inspect the locations where<br/>
        tornadoes are most common across Australia. 
      </p>
  
      <!-- 1) tornado_density_across_australia -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornado Density Across Australia between 1900 and 2025</h3>
            <p class="viz-sub">Aggregated by 3 degree bins and scaled by frequency.</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-tornado-density" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="tornado-size-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Tornado count</div>
              <svg id="tornado-size-legend-svg" role="img" aria-label="Tornado count legend"></svg>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        From the above map we can see that much of<br/>
        Australia experiences <span class="highlight">tornadoes</span>. The Bureau of Metereology (BOM)<br/>
        has a repository dedicated to <span class="highlight">severe weather</span>. Using this<br/>
        we can see how prevelant tornadoes are in<br/>
        comparison to other weather events.
      </p>
  
      <!-- 2) severe_weather_proportions_per_state -->
      <section class="viz-card">
        <h3 class="viz-title">Severe weather distribution between 1900 and 2025 by State</h3>
        <p class="viz-sub">ACT was excluded due to its small data size.</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-severe-proportions" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="severe-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Severe weather</div>
              <svg id="severe-legend-svg" width="200" height="140" role="img" aria-label="Severe weather legend"></svg>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        The <span class="highlight">Fujita rating</span> measures tornado strength.<br/>
        It was proposed in 1971 by Dr. Tetsuya Fujita.<br/>
        Dr. Fujita worked at the University of Chicago.<br/>
        Much research into severe storms focuses in the United States.<br/>
        The United States experiences a large number of <span class="highlight">tornadoes</span>.<br/>
        Tornadoes are unpredictable and difficult to study.<br/>
        Dr. Fujita proposed using a destruction scale to infer winds.<br/><br/>
        For example, destroying mobile homes requires winds above 180 km/h.<br/>
        If mobile homes are destroyed, winds must have reached that magnitude.<br/>
        Tornadoes are broadly categorised on the F0 to F5 scale.<br/>
        In 2007 the <span class="highlight">Enhanced Fujita</span> scale was introduced.<br/>
        The Enhanced Fujita refined the damage rating categories.
      </p>
  
      <!-- 3+4) dynamic maps row: Australian and US maps (vertically placed) -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornadoes by Fujita rating — Australia and U.S. bewteen 2010 and 2014.</h3>
            <p class="viz-sub">Dynamic maps generated from per-rating CSVs; toggle ratings using the checkboxes below. Inspect the locations that experienced the most tornadoes and the most severe tornadoes.</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left map-stack-left">
            <!-- stacked maps (vertical) -->
            <div id="aus-chart" class="viz-embed map-stack-item" aria-label="Australia tornado map"></div>
            <div id="us-chart" class="viz-embed map-stack-item" aria-label="United States tornado map"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Map legend and controls">
            <div id="combined-rating-legend" class="size-legend" role="group" aria-label="Fujita rating legend">
              <div class="legend-title">Fujita rating</div>
      
              <div id="legend-checkboxes" aria-label="Fujita rating toggles" role="list"></div>
      
              <!-- color swatches + descriptions rendered by drawFujitaColorLegend -->
              <div id="fujita-legend" class="fujita-legend" role="list" aria-label="Fujita scale colours"></div>
      
              <!-- optional small help text -->
              <div class="legend-note" style="margin-top:8px; color:#55607a; font-size:12px;">
                Toggle ratings to show or hide that class on the maps.
              </div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        The above map really puts into perspective the number<br/>
        of tornadoes the U.S. gets each year.<br/><br/>
        Look at the below graph to get an idea of<br/>
        how the number of recorded tornadoes has changed<br/>
        and how many are <span class="highlight">damaging tornadoes</span>.
      </p>

      <!-- 5) tornadoes_by_fujita_rating_and_year -->
      <section class="viz-card">
        <h3 class="viz-title">The Number of Recorded Tornadoes in the U.S. since 1950</h3>
        <p class="viz-sub">The values are broken down by fujita rating.</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-total-tornadoes" class="viz-embed"></div>
          </div>

          <div class="legend-right" aria-hidden="false" role="region" aria-label="Fujita scale legend">
            <div id="fujita-static-legend" class="size-legend" role="group" aria-label="Fujita scale colours">
              <div class="legend-title">Fujita Scale</div>
              <div id="fujita-static-swatches" class="fujita-legend" role="list" aria-label="Fujita scale colours"></div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Whilst Australia obviously experiences <span class="highlight">far fewer servere tornado events</span><br/>
        than the United States, we still experience strong tornadoes<br/>
        with the fastest being <span class="highlight">F4 rated</span>.<br/><br/>
        As noted before. Wind speeds are <span class="highlight">estimated based on damage</span>.<br/> 
        When the BOM is surveying tornado damage, they estimate the<br/>
        associated wind strength. Use the time sliders in the<br/>
        below visualisation to see the <span class="highlight">fastest tornadoes</span><br/>
        in a given period.
      </p>
  
      <!-- 6) fastest_australian_tornadoes -->
      <section class="viz-card">
        <h3 class="viz-title">Top Five Fastest Tornadoes by Wind Speed Since 1900</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-fastest-aus" class="viz-embed"></div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Tornadoes are <span class="highlight">very seasonal events</span>. They require certain conditions to<br/>
        occur, such as a <span class="highlight">lifting mechanism</span>, a <span class="highlight">moist atmosphere</span><br/>
        and also <span class="highlight">conditional instability</span>. Because of this,<br/>
        <span class="highlight">Spring</span> is the most common season to experience tornadoes,<br/>
        although they can happen at <span class="highlight">any time of the year</span>.<br/>
        View below the distribution of tornadoes across months in<br/>
        <span class="highlight">Australia</span> — a Southern Hemisphere country — and the<br/>
        <span class="highlight">United States</span> — a Northern Hemisphere country.
      </p>

      <!-- 7) tornadoes_by_month_aus_vs_us -->
      <section class="viz-card">
        <h3 class="viz-title">Tornadoes by month — Australia vs U.S.</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-by-month" class="viz-embed"></div>
          </div>

        <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
          <div id="country-legend" class="size-legend" role="group" aria-label="Country colours">
            <div class="legend-title">Country</div>
            <div id="country-legend-swatches" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
          </div>
        </div>
        </div>
      </section>
        
      <p class="intro-paragraph">
        With <span class="highlight">wind speeds high enough to shred</span><br/>
        a well-built house off its foundations,<br/>
        tornadoes have sadly <span class="highlight">claimed many lives</span>.<br/>
        See below a chart of some of the<br/>
        <span class="highlight">deadliest tornadoes of all time</span>.
      </p>
  
      <!-- 8) deadliest_tornadoes_bubble_chart -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes — bubble chart</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-deadliest-bubble" class="viz-embed"></div>
          </div>

          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="deadliest-country-legend" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="deadliest-country-swatches" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        See the general locations of the deadliest<br/>
        tornadoes visualised on a map.
      </p>
   
      <!-- 9) deadliest_tornadoes_on_a_map -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes on a map</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-deadliest-map" class="viz-embed"></div>
          </div>

          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="deadliest-country-legend-map" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="deadliest-country-swatches-map" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- 10) El-reno example -->
      <section class="viz-card el-reno-block" aria-labelledby="el-reno-title">
        <h3 id="el-reno-title" class="viz-title">El Reno Tornado — profile and hodograph</h3>
      
        <!-- IMAGE ROW: back in place -->
        <div class="el-reno-image-row">
          <figure class="el-reno-figure">
            <img src="el-reno.jpg" alt="El Reno tornado, May 2013" width="900" height="506" loading="lazy">
            <figcaption class="el-reno-caption">The El Reno tornado, May 2013 — one of the largest observed.</figcaption>
          </figure>
        </div>
      
        <!-- TWO-COLUMN ROW: left = text, right = hodograph + legend -->
        <div class="el-reno-two-col" role="region" aria-label="El Reno text and hodograph">
          <div class="el-reno-left">
            <p class="el-reno-narrow">
              Wind shear that <span class="highlight">turns</span> and <span class="highlight">increases</span> with height
              helps create the rotation seen in the hodograph. The final sounding after the tornado shows strong
              low‑level curvature and speed increases, indicating streamwise vorticity being tilted into the updraft.
            </p>
          </div>
      
          <div class="el-reno-right">
            <div id="viz-el-reno-hodograph" class="viz-embed" aria-label="El Reno hodograph"></div>
      
            <div class="el-reno-legend-box" aria-hidden="false">
              <div class="legend-title">Altitude (m)</div>
              <div id="el-reno-order-swatches" class="fujita-legend" role="list" aria-label="Altitude colours"></div>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        In conclusion, <span class="highlight">Australia has experienced its share of tornadoes</span><br/>
        and severe weather, with notable events scattered across<br/>
        the continent. However, the <span class="highlight">United States remains the global epicenter</span><br/>
        of tornado activity — both in frequency and intensity.<br/>
        This visualisation explored the <span class="highlight">seasonal nature of tornadoes</span>,<br/>
        the role of <span class="highlight">wind shear and hodographs</span> in supercell formation,<br/>
        and highlighted some of the <span class="highlight">deadliest</span> and <span class="highlight">fastest tornadoes</span> on record.<br/>
        We examined <span class="highlight">dot maps</span> showing where tornadoes occur most often<br/>
        in both the U.S. and Australia, and reviewed the<br/>
        <span class="highlight">distribution of severe weather across Australia</span>.<br/>
        Together, these insights help us better understand the<br/>
        <span class="highlight">patterns, risks, and dynamics</span> of tornado formation<br/>
        across hemispheres.
      </p>
    </div>
  </div>

  <script>
    // ------------------------
    // Configuration
    // ------------------------

    // JSON spec filenames placed beside index.html in the same repo/folder
    const specs = {
      tornadoDensity: "tornado_density_across_australia.json",
      severeProportions: "severe_weather_proportions_per_state.json",
      fastestAus: "fastest_australian_tornadoes.json",
      totalTornadoes: "tornadoes_by_fujita_rating_and_year.json",
      byMonth: "tornadoes_by_month_aus_vs_us.json",
      deadliestBubble: "deadliest_tornadoes_bubble_chart.json",
      deadliestMap: "deadliest_tornadoes_on_a_map.json",
      elRenoHodograph: "el-reno_hodograph.json",
    };

    // CSV / topo repo used for dynamic maps (the repo you used previously)
    // If you want to change the repo, update this base path.
    const csvRepoBase = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/";

    // Patterns and topo files (update repo path if needed)
    const ausCsvPattern = csvRepoBase + "Tornado_F{R}_2010_2024_Australia.csv";
    const usCsvPattern  = csvRepoBase + "Tornado_F{R}_2010_2024_America.csv";

    const ausBaseTopo = csvRepoBase + "australia.json";
    const ausGraticules = csvRepoBase + "10_degree_graticules_for_australia.json";

    const usBaseTopo = csvRepoBase + "mainland_united_states.json";
    const usGraticules = csvRepoBase + "10_degree_graticules_for_united_states.json";

    // Fujita rating colours and list (initial selection: all)
    const ratingColors = {
      "F0": "#999999",
      "F1": "#E69F00",
      "F2": "#56B4E9",
      "F3": "#009E73",
      "F4": "#F0E442",
      "F5": "#984ea3"
    };
    const ratings = ["F0","F1","F2","F3","F4","F5"];
    let selectedRatings = new Set(ratings);

    // Latitude/longitude field names in the CSVs
    const ausLatField = "Latitude";
    const ausLonField = "Longitude";
    const usLatField = "BEGIN_LAT";
    const usLonField = "BEGIN_LON";

    // ------------------------
    // Helpers
    // ------------------------

    async function embedSpec(target, urlOrSpec) {
      try {
        await vegaEmbed(target, urlOrSpec, { 
          actions: false, 
          renderer: "canvas",
          tooltip: { 
            theme: 'custom',
            disableDefaultStyle: true
          }
        });
      } catch (err) {
        document.querySelector(target).innerHTML = "<div style='padding:12px;color:#900;'>Failed to render: " + (err.message || err) + "</div>";
        console.error("Embed error", err);
      }
    }

    async function fetchCsv(url) {
      try {
        const r = await fetch(url);
        if (!r.ok) return [];
        const text = await r.text();
        const lines = text.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const cols = lines[0].split(",");
        const rows = [];
        for (let i=1;i<lines.length;i++){
          const vals = lines[i].split(",");
          const obj = {};
          for (let j=0;j<cols.length;j++){
            obj[cols[j]] = vals[j] !== undefined ? vals[j] : "";
          }
          rows.push(obj);
        }
        return rows;
      } catch (e) {
        console.warn("CSV fetch failed", url, e);
        return [];
      }
    }

    // ------------------------
    // Creating legends 
    // ------------------------

    function drawTornadoSizeLegend(containerId = "tornado-size-legend-svg") {
      const domain = [1, 160];
      const rangeArea = [50, 840]; // same as Vega-Lite size scale (area in px^2)
      const counts = [150, 100, 30, 1]; // draw largest first (top) — change order if you prefer
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // helpers
      const areaForCount = c => {
        const t = (c - domain[0]) / (domain[1] - domain[0]);
        return rangeArea[0] + t * (rangeArea[1] - rangeArea[0]);
      };
      const radiusForArea = a => Math.sqrt(a / Math.PI);
    
      // clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      // layout params
      const paddingLeft = 12;
      const paddingTop = 12;
      const itemGap = 12;         // vertical gap between items
      const labelGap = 8;         // horizontal gap between circle and label
      const labelFontSize = 12;
    
      // compute radii and max width needed
      const radii = counts.map(c => radiusForArea(areaForCount(c)));
      const maxR = Math.max(...radii);
      const circleColWidth = Math.ceil(2 * maxR); // column reserved for circle diameter
      const labelColWidth = 70;                    // reserve for labels (adjust if needed)
    
      // initial positions
      let y = paddingTop;
    
      counts.forEach((c, i) => {
        const r = radii[i];
        const cx = paddingLeft + maxR;           // center circles in left column
        const cy = y + r;
    
        // circle
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", cx);
        circ.setAttribute("cy", cy);
        circ.setAttribute("r", r);
        circ.setAttribute("fill", "#0072B2");
        circ.setAttribute("fill-opacity", "0.85");
        circ.setAttribute("stroke", "#fff");
        circ.setAttribute("stroke-width", "1");
        svg.appendChild(circ);
    
        // label to the right of circle
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + circleColWidth + labelGap);
        label.setAttribute("y", cy + (labelFontSize / 3)); // vertically align text near center
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.textContent = String(c);
        svg.appendChild(label);
    
        // advance y for next item: circle diameter + gap
        y += Math.ceil(2 * r + itemGap);
      });
    
      // finalize svg size
      const totalWidth = paddingLeft + circleColWidth + labelGap + labelColWidth + 12;
      const totalHeight = y + 8;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function drawSevereLegendVertical(containerId = "severe-legend-svg") {
      // color mapping (matches your glyph colors)
      const items = [
        { key: "rain_mentions", label: "Rain", color: "#0072B2" },
        { key: "hail_mentions", label: "Hail", color: "#009E73" },
        { key: "tornado_mentions", label: "Tornado", color: "#D55E00" }
      ];
    
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // layout params chosen to match visual footprint of the tornado vertical legend
      const paddingLeft = 12;
      const paddingTop = 12;
      const swatchSize = 18;    // square swatch size
      const itemGap = 14;       // vertical gap between items
      const labelGap = 10;      // horizontal gap between swatch and label
      const labelFontSize = 12;
    
      // clear existing content
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      let y = paddingTop;
    
      items.forEach((it, i) => {
        // swatch (rounded rect)
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", paddingLeft);
        rect.setAttribute("y", y);
        rect.setAttribute("width", swatchSize);
        rect.setAttribute("height", swatchSize);
        rect.setAttribute("rx", 3);
        rect.setAttribute("ry", 3);
        rect.setAttribute("fill", it.color);
        rect.setAttribute("stroke", "#fff");
        rect.setAttribute("stroke-width", "1");
        svg.appendChild(rect);
    
        // label text
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + swatchSize + labelGap);
        label.setAttribute("y", y + swatchSize - 4);
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.setAttribute("class", "severe-legend-swatch-label");
        label.textContent = it.label;
        svg.appendChild(label);
    
        y += swatchSize + itemGap;
      });
    
      const totalWidth = paddingLeft + swatchSize + labelGap + 80;
      const totalHeight = y + 6;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function makeLegendRows(container, items, colors, opts = {}) {
      const swW = opts.swatchWidth || 24;
      const swH = opts.swatchHeight || 14;
      if (!container) return;
    
      container.innerHTML = "";
      container.style.display = "flex";
      container.style.flexDirection = "column";
      container.style.gap = "6px";
      container.style.marginTop = "8px";
      container.style.boxSizing = "border-box";
    
      items.forEach(labelText => {
        const row = document.createElement("div");
        row.className = "f-row";
        row.setAttribute("role", "listitem");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.fontSize = "13px";
        row.style.color = "#123047";
        row.style.padding = "0";
        row.style.minHeight = "20px";
        row.style.boxSizing = "border-box";
    
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.width = swW + "px";
        sw.style.height = swH + "px";
        sw.style.background = colors[labelText] || "#999";
        sw.style.borderRadius = "3px";
        sw.style.border = "1px solid rgba(0,0,0,0.08)";
        sw.style.boxShadow = "inset 0 -1px 0 rgba(0,0,0,0.06)";
        sw.style.display = "inline-block";
        sw.setAttribute("aria-hidden", "true");
    
        const label = document.createElement("span");
        label.className = "f-label";
        label.textContent = labelText;
        label.style.fontWeight = "700";
        label.style.fontFamily = "Inter, sans-serif";
        label.style.lineHeight = "1";
        label.style.display = "inline-block";
    
        row.appendChild(sw);
        row.appendChild(label);
        container.appendChild(row);
      });
    }
    
    function drawCountryLegend(containerId = "country-legend-swatches") {
      const container = document.getElementById(containerId);
      if (!container) return;
      const countries = ["Australia", "America"];
      const countryColors = { "Australia": "#0072B2", "America": "#D55E00" };
      makeLegendRows(container, countries, countryColors, { swatchWidth: 24, swatchHeight: 14 });
    }
    
    function drawDeadliestCountryLegend(containerId = "deadliest-country-swatches") {
      const container = document.getElementById(containerId);
      if (!container) return;
      const countries = ["Bangladesh","United States","Russia","Italy","Malta","Argentina","Australia"];
      const countryColors = {
        "Bangladesh": "#E69F00",
        "United States": "#56B4E9",
        "Russia": "#009E73",
        "Italy": "#F0E442",
        "Malta": "#0072B2",
        "Argentina": "#D55E00",
        "Australia": "#CC79A7"
      };
      makeLegendRows(container, countries, countryColors, { swatchWidth: 24, swatchHeight: 14 });
    }
    
    // ------------------------
    // Adding annotations
    // ------------------------

    /* Charts */

    async function embedWithHtmlAnnotationsForCartesian(target, specUrlOrObject, options = {}) {
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = Object.assign({
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      }, options.embedOptions || {});
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
      if (view && typeof view.runAsync === "function") await view.runAsync();
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      // create/replace overlay SVG for leader lines and markers
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function getScaleFn(scaleName) {
        try {
          if (!view || typeof view.scale !== "function") return null;
          const s = view.scale(scaleName);
          if (typeof s !== "function") return null;
          return s;
        } catch (e) {
          return null;
        }
      }
    
      function dataToPixels(xVal, yVal) {
        const xScale = getScaleFn('x') || getScaleFn('xscale') || getScaleFn('xscale0') || null;
        const yScale = getScaleFn('y') || getScaleFn('yscale') || getScaleFn('yscale0') || null;
        const px = xScale ? xScale(xVal) : null;
        const py = yScale ? yScale(yVal) : null;
        return { x: px, y: py };
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        // clear overlay lines and boxes
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
        // create boxes first (so we can measure)
        const created = annotations.map(a => {
          const src = a.src || {};
          // compute anchor pixel from src (used for marker + start of line)
          let anchorPx = null;
          if (typeof src.x === "number" && typeof src.y === "number") {
            const pt = dataToPixels(src.x, src.y);
            if (pt.x != null && pt.y != null) anchorPx = pt;
          }
    
          // compute box position from boxXY (preferred) or fallback to src
          const boxCoord = (a.boxXY && typeof a.boxXY.x === "number" && typeof a.boxXY.y === "number")
            ? a.boxXY
            : (typeof src.x === "number" && typeof src.y === "number" ? { x: src.x, y: src.y } : null);
    
          if (!boxCoord) return null;
          const boxPx = dataToPixels(boxCoord.x, boxCoord.y);
          if (boxPx.x == null || boxPx.y == null) return null;
    
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
          div.style.position = "absolute";
          div.style.pointerEvents = "auto";
    
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
    
          // default placement: box at projected boxPx + nudges
          let leftPx = boxPx.x + nudgeX;
          let topPx  = boxPx.y + nudgeY;
    
          // append off-DOM to measure size
          div.style.left = "-9999px";
          div.style.top = "-9999px";
          container.appendChild(div);
          const measured = div.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const w = Math.min(boxMaxWidth, measured.width);
          const h = measured.height;
    
          // adjust left/top to fit inside container bounds
          const margin = 8;
          if (leftPx + margin + w > width) leftPx = Math.max(margin, width - w - margin);
          if (leftPx < margin) leftPx = margin;
          if (topPx < margin) topPx = margin;
          if (topPx > height - 40) topPx = height - 40;
    
          div.style.left = Math.round(leftPx) + "px";
          div.style.top  = Math.round(topPx) + "px";
    
          return { a, div, anchorPx, left: leftPx, top: topPx, width: w, height: h };
        }).filter(Boolean);
    
        // draw leader lines from anchor to nearest box edge and markers where anchor exists
        created.forEach(c => {
          const anchor = c.anchorPx;
          if (!anchor) return; // no anchor => no line/marker
    
          const boxLeft = c.left;
          const boxRight = c.left + c.width;
          const boxTop = c.top;
          const boxBottom = c.top + c.height;
    
          // pick attachment point on box edge (prefer left edge if box is left of anchor)
          let attachX, attachY;
          if (anchor.x > boxRight) {
            attachX = boxRight;
            attachY = Math.min(Math.max(anchor.y, boxTop), boxBottom);
          } else if (anchor.x < boxLeft) {
            attachX = boxLeft;
            attachY = Math.min(Math.max(anchor.y, boxTop), boxBottom);
          } else if (anchor.y < boxTop) {
            attachY = boxTop;
            attachX = Math.min(Math.max(anchor.x, boxLeft), boxRight);
          } else {
            attachY = boxBottom;
            attachX = Math.min(Math.max(anchor.x, boxLeft), boxRight);
          }
    
          // draw line (explicit stroke defaulting to black)
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", Math.round(anchor.x));
          line.setAttribute("y1", Math.round(anchor.y));
          line.setAttribute("x2", Math.round(attachX));
          line.setAttribute("y2", Math.round(attachY));
          line.setAttribute("class", "annotation-line");
          line.setAttribute("stroke", (c.a && c.a.lineColor) ? c.a.lineColor : "#000000");
          line.setAttribute("stroke-width", (c.a && c.a.lineWidth) ? String(c.a.lineWidth) : "1.2");
          line.setAttribute("stroke-opacity", (c.a && c.a.lineOpacity) ? String(c.a.lineOpacity) : "0.95");
          overlay.appendChild(line);
    
          // draw marker at anchor (explicit fill/stroke defaults)
          const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          marker.setAttribute("cx", Math.round(anchor.x));
          marker.setAttribute("cy", Math.round(anchor.y));
          marker.setAttribute("r", (c.a && c.a.markerRadius) ? String(c.a.markerRadius) : "4");
          marker.setAttribute("class", "annotation-marker");
          marker.setAttribute("fill", (c.a && c.a.markerFill) ? c.a.markerFill : "#000000");
          marker.setAttribute("stroke", (c.a && c.a.markerStroke) ? c.a.markerStroke : "#ffffff");
          overlay.appendChild(marker);
        });
    
        return created;
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on resize or view updates
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
    
      // observe container size changes
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }
    /* Map annotations */
    
    async function embedWithHtmlAnnotations(target, specUrlOrObject, options = {}) {
      const projOpts = Object.assign({
        type: "mercator",
        center: [134, -28],
        scale: 850
      }, options.projection || {});
    
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = {
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      };
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
    
      if (view && typeof view.runAsync === "function") {
        await view.runAsync();
      }
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      // create/replace overlay SVG (kept for compatibility but not used for lines/markers)
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.setAttribute("preserveAspectRatio", "xMinYMin meet");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function makeProjection(width, height) {
        const vw = (view && typeof view.width === "function") ? view.width() : width;
        const vh = (view && typeof view.height === "function") ? view.height() : height;
        const geo = (typeof d3 !== "undefined" && typeof d3.geoMercator === "function") ? d3 : null;
        if (!geo) throw new Error("d3.geoMercator not available; include d3 (e.g. https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js)");
        return geo.geoMercator().center(projOpts.center).scale(projOpts.scale).translate([vw / 2, vh / 2]);
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        const proj = makeProjection(width, height);
        function projectPoint(lon, lat) {
          const p = proj([lon, lat]);
          return { x: p[0], y: p[1] };
        }
    
        // clear overlay contents and previous boxes
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
        // create boxes only (no lines or markers)
        const createdBoxes = annotations.map(a => {
          // prefer explicit boxLonLat for where the HTML box should sit
          const boxLon = (a.boxLonLat && typeof a.boxLonLat.lon === "number") ? a.boxLonLat.lon
                        : (a.src && typeof a.src.lon === "number" ? a.src.lon : null);
          const boxLat = (a.boxLonLat && typeof a.boxLonLat.lat === "number") ? a.boxLonLat.lat
                        : (a.src && typeof a.src.lat === "number" ? a.src.lat : null);
    
          // if we still don't have coords, skip this annotation
          if (boxLon === null || boxLat === null) return null;
    
          const boxPx = projectPoint(boxLon, boxLat);
    
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
    
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
    
          let left = Math.round(boxPx.x + container.scrollLeft + nudgeX);
          let top  = Math.round(boxPx.y + container.scrollTop + nudgeY);
    
          const containerRect = container.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const margin = 8;
    
          if (left + margin + boxMaxWidth > containerRect.width) left = Math.max(margin, containerRect.width - boxMaxWidth - margin);
          if (left < margin) left = margin;
          if (top < margin) top = margin;
          if (top > containerRect.height - 40) top = containerRect.height - 40;
    
          div.style.left = left + "px";
          div.style.top  = top + "px";
    
          container.appendChild(div);
    
          return {
            a,
            div,
            left,
            top,
            width: Math.min(boxMaxWidth, div.getBoundingClientRect().width),
            height: div.getBoundingClientRect().height,
            anchorPx: boxPx
          };
        }).filter(Boolean);
    
        // no leader lines or markers are created
        return createdBoxes;
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on window + container resize
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }

    // ------------------------
    // Dynamic maps (Australia and US) logic
    // ------------------------

    function drawFujitaColorLegend(containerId = "fujita-legend", opts = {}) {
      const container = document.getElementById(containerId);
      if (!container) return;
    
      const interactive = opts.interactive !== false; // default to true
      const descriptions = opts.descriptions || {
        "F0": "Gale damage",
        "F1": "Moderate damage",
        "F2": "Considerable damage",
        "F3": "Severe damage",
        "F4": "Devastating damage",
        "F5": "Incredible damage"
      };
    
      container.innerHTML = "";
    
      ratings.forEach(r => {
        const row = document.createElement("div");
        row.className = "f-row legend-item";
        row.setAttribute("role", "listitem");
        row.setAttribute("data-rating", r);
    
        if (interactive) {
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.className = "legend-checkbox";
          cb.value = r;
          cb.checked = selectedRatings.has(r);
          cb.setAttribute("aria-label", r + " toggle");
          cb.addEventListener("change", onLegendToggle);
          row.appendChild(cb);
    
          row.addEventListener("click", (e) => {
            if (e.target === cb) return;
            cb.checked = !cb.checked;
            cb.dispatchEvent(new Event("change", { bubbles: true }));
          });
    
          if (!cb.checked) row.classList.add("disabled");
        }
    
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = ratingColors[r] || "#ccc";
        sw.setAttribute("aria-hidden", "true");
    
        const label = document.createElement("span");
        label.className = "f-label legend-label";
        label.textContent = r;
    
        const desc = document.createElement("span");
        desc.className = "f-desc legend-desc";
        desc.textContent = descriptions[r] || "";
    
        row.appendChild(sw);
        row.appendChild(label);
        row.appendChild(desc);
    
        container.appendChild(row);
      });
    }

    function onLegendToggle(e) {
      const rating = e.target.value;
      const checked = e.target.checked;
      const item = e.target.closest(".legend-item");
      if (!item) return;
      if (!checked) {
        selectedRatings.delete(rating);
        item.classList.add("disabled");
      } else {
        selectedRatings.add(rating);
        item.classList.remove("disabled");
      }
      renderMaps(); // re-render maps with updated selectedRatings
    }

    async function renderMaps() {
      // build base layers
      const ausLayers = [
        {
          data: { url: ausBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: ausGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      const usLayers = [
        {
          data: { url: usBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: usGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      // gather per-rating point layers (only for selected ratings)
      for (const r of ratings) {
        if (!selectedRatings.has(r)) continue;

        const ausUrl = ausCsvPattern.replace("{R}", r.slice(1));
        const usUrl  = usCsvPattern.replace("{R}", r.slice(1));

        // fetch CSVs (graceful if missing)
        const [ausRows, usRows] = await Promise.all([fetchCsv(ausUrl), fetchCsv(usUrl)]);

        const ausValues = ausRows.map(row => {
          const out = Object.assign({}, row);
          if (out[ausLatField] !== undefined) out[ausLatField] = parseFloat(out[ausLatField]);
          if (out[ausLonField] !== undefined) out[ausLonField] = parseFloat(out[ausLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        const usValues = usRows.map(row => {
          const out = Object.assign({}, row);
          if (out[usLatField] !== undefined) out[usLatField] = parseFloat(out[usLatField]);
          if (out[usLonField] !== undefined) out[usLonField] = parseFloat(out[usLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        // push a point layer for this rating
        ausLayers.push({
          data: { values: ausValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: ausLonField, type: "quantitative" },
            latitude: { field: ausLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });

        usLayers.push({
          data: { values: usValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: usLonField, type: "quantitative" },
            latitude: { field: usLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
      } // end per-rating loop

      // Construct final specs
      const ausSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 840,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [134, -28], scale: 850 },
        layer: ausLayers,
        config: { view: { stroke: null } }
      };

      const usSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 840,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [-98, 38], scale: 750 },
        layer: usLayers,
        config: { view: { stroke: null } }
      };
      
      document.getElementById("aus-chart").innerHTML = "";
      document.getElementById("us-chart").innerHTML = "";
      
      // set spec widths consistent with CSS viz-left width (840)
      ausSpec.width = 840;
      usSpec.width = 840;
      
      await embedWithHtmlAnnotations("#aus-chart", ausSpec, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          // Alice Springs area — moved further left and line break after "central"
          {
            id: "alice-springs-note",
            boxLonLat: { lon: 128.5, lat: -22.5 },
            label: "Recorded tornadoes in central\nAustralia are extremely rare",
            nudgeX: -60,
            nudgeY: -10
          },
      
          // Offshore south of WA — moved ~5° south and a bit east
          {
            id: "wa-coast-note",
            boxLonLat: { lon: 116.0, lat: -36.5 },
            label: "Notice tornadoes cluster near populated areas; others may occur unrecorded offshore or remote inland",
            nudgeX: -180,
            nudgeY: 8
          }
        ]
      });

      await embedWithHtmlAnnotations("#us-chart", usSpec, {
        projection: { center: [-95, 37], scale: 900 },
        annotations: [
          {
            id: "ca-offshore-note",
            // anchor point can be near the western interior (used only if you supplied src previously)
            src: { lon: -119.0, lat: 30.0 },
            // place the HTML box so its left edge is approximately in line with California (lon -120)
            // and positioned ~5° north of Washington (~lat 52)
            boxLonLat: { lon: -117.0, lat: 52.0 },
            label: "Tornadoes are less common in the western US but still occur",
            nudgeX: -12,
            nudgeY: -6,
            maxWidth: 320
          },
      
          {
            id: "southeast-note",
            // keep anchor near Alabama if you want the logical association, but move box position west a bit
            src: { lon: -86.9, lat: 32.3 },
            // box moved west so it sits more over the central Gulf / lower Mississippi longitudes
            boxLonLat: { lon: -90.5, lat: 30.0 },
            label: "Dangerous tornadoes are concentrated in the southeast states",
            nudgeX: -40,
            nudgeY: 10,
            maxWidth: 300
          }
        ]
      });
    }

    // ------------------------
    // El Reno hodograph
    // ------------------------
    
    function renderAltitudeLegend(containerId, domainMin = 0, domainMax = 400) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = '';
    
      // compact container sizing
      container.style.display = 'inline-block';
      container.style.width = '120px';
      container.style.maxWidth = '120px';
      container.style.boxSizing = 'border-box';
      container.style.padding = '0';
      container.style.margin = '0';
    
      const svgW = 28;
      const svgH = 160;
      const paddingRight = 34;
      const totalW = svgW + paddingRight;
      const svgNS = 'http://www.w3.org/2000/svg';
    
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${totalW} ${svgH}`);
      svg.style.width = '100%';
      svg.style.height = 'auto';
      svg.style.display = 'block';
    
      const defs = document.createElementNS(svgNS, 'defs');
      const grad = document.createElementNS(svgNS, 'linearGradient');
      const gradId = `viridis_${containerId}`;
      grad.setAttribute('id', gradId);
      grad.setAttribute('x1', '0'); grad.setAttribute('y1', '0'); grad.setAttribute('x2', '0'); grad.setAttribute('y2', '1');
      [['0','#440154'],['25','#3b528b'],['50','#21918c'],['75','#5ec962'],['100','#fde725']]
        .forEach(([o,c]) => {
          const stop = document.createElementNS(svgNS,'stop');
          stop.setAttribute('offset', `${o}%`);
          stop.setAttribute('stop-color', c);
          grad.appendChild(stop);
        });
      defs.appendChild(grad);
      svg.appendChild(defs);
    
      const rect = document.createElementNS(svgNS, 'rect');
      rect.setAttribute('x', 0); rect.setAttribute('y', 8);
      rect.setAttribute('width', svgW); rect.setAttribute('height', svgH - 16);
      rect.setAttribute('fill', `url(#${gradId})`);
      svg.appendChild(rect);
    
      const g = document.createElementNS(svgNS, 'g');
      g.setAttribute('transform', `translate(${svgW + 6},0)`);
      const gradientInterior = svgH - 16;
      const ticks = [domainMin, domainMax * 0.25, domainMax * 0.5, domainMax * 0.75, domainMax];
      ticks.forEach(t => {
        const y = 8 + gradientInterior * (1 - (t - domainMin) / (domainMax - domainMin));
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', 0); line.setAttribute('x2', 6);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#333'); line.setAttribute('stroke-width', '0.6');
        g.appendChild(line);
        const txt = document.createElementNS(svgNS, 'text');
        txt.setAttribute('x', 10); txt.setAttribute('y', y + 4);
        txt.setAttribute('font-size', '11'); txt.setAttribute('fill', '#222');
        txt.textContent = Math.round(t);
        g.appendChild(txt);
      });
      svg.appendChild(g);
      container.appendChild(svg);
    
      // ensure ancestor wrapper not forcing width
      const sizeLegend = container.closest('.size-legend');
      if (sizeLegend) {
        sizeLegend.style.width = 'auto';
        sizeLegend.style.maxWidth = '140px';
        sizeLegend.style.boxSizing = 'border-box';
        sizeLegend.style.padding = '0';
      }
    }
    
    // ------------------------
    // Initialization: embed static specs and start dynamic maps
    // ------------------------
    async function init() {
      
      // Embed static JSON specs (they should be placed beside index.html or referenced by full path)
      
      await embedWithHtmlAnnotations("#viz-tornado-density", specs.tornadoDensity, { // embed the density visualisation and add annotations
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "victoria-hotspot",
            boxLonLat: { lon: 128, lat: -38 },
            label: "Southern Victoria experienced the\nmost recorded tornadoes",
            nudgeX: -160,
            nudgeY: 20,
          },
          {
            id: "tropics-note",
            boxLonLat: { lon: 108, lat: -12 },
            label: "Tropics see more storms but\nfewer recorded tornadoes",
          }
        ]
      });

      drawTornadoSizeLegend();

      await embedWithHtmlAnnotations("#viz-severe-proportions", specs.severeProportions, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "sa-tornado-proportion",
            boxLonLat: { lon: 116.5, lat: -36.5 },
            label: "South Australia has the highest proportion\nof tornado-related severe weather — around 24%",
            leader: true,
            nudgeX: -40,                             // slightly reduced nudge
            nudgeY: 10
          }
        ]
      });
      drawSevereLegendVertical(); 

      drawFujitaColorLegend('fujita-legend');
      renderMaps();

      await embedWithHtmlAnnotations("#viz-fastest-aus", specs.fastestAus, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          // Western Australia note (on land in WA)
          {
            id: "wa-fastest",
            boxLonLat: { lon: 125.5, lat: -43.5 }, // where the annotation box should sit
            label: "The fastest tornadoes in WA occurred in the 21st century",
            nudgeX: -180,                           // tune horizontal pixel offset for box
            nudgeY: -10                             // tune vertical pixel offset for box
          },
      
          // Queensland / NSW coastal note (placed offshore/coast)
          {
            id: "nsw-qld-note",
            boxLonLat: { lon: 162.0, lat: -20.0 }, // box near coast between QLD and NSW
            label: "NSW and QLD witness\nthe most tornadoes",
            nudgeX: -40,
            nudgeY: 8
          }
        ]
      });

      // US tornadoes by year and fujita rating
      await embedWithHtmlAnnotationsForCartesian("#viz-total-tornadoes", specs.totalTornadoes, {
        annotations: [
          {
            id: "peak-2011",
            // anchor at the data point (Year, Count)
            src: { x: 2011, y: 2074 },
      
            // move the HTML box further left and slightly higher than before
            boxXY: { x: 1978, y: 2350 },
      
            // label text with a line break
            label: "2011 saw the most tornadoes\nwith 2,074 recorded",
      
            // small pixel nudges after projection (tweak if needed)
            nudgeX: -6,
            nudgeY: -6,
      
            // visual tuning
            maxWidth: 320,
            lineColor: "#e07b39",
            lineWidth: 1.6,
            lineOpacity: 0.95,
            markerRadius: 4,
            markerFill: "#e07b39",
            markerStroke: "#ffffff"
          }
        ]
      });
      drawFujitaColorLegend("fujita-static-swatches", { interactive: false }); // this chart shouldn't have the toggle effect
      
      // other later static specs
      await embedSpec("#viz-by-month", specs.byMonth);
      drawCountryLegend("country-legend-swatches");

      await embedSpec("#viz-deadliest-bubble", specs.deadliestBubble);
      drawDeadliestCountryLegend()
      
      await embedSpec("#viz-deadliest-map", specs.deadliestMap);
      drawDeadliestCountryLegend("deadliest-country-swatches-map");

      await embedSpec("#viz-el-reno-hodograph", specs.elRenoHodograph);
      renderAltitudeLegend("el-reno-order-swatches", 0, 400);
    }

    // run
    init();
  </script>
</body>
</html>
</body>
</html>
