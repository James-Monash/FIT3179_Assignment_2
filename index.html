<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Severe Weather Visualisations</title>

  <!-- Vega / Vega-Lite / Vega-Embed -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-tooltip@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script> <!-- we use this to calculate projections and ensure annotations remain in the correct position -->

  <style>
    #vg-tooltip-element {
      visibility: hidden;
      position: fixed;
      z-index: 9999;
      padding: 10px 12px;
      max-width: 360px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.12);
      border: 1px solid rgba(34,40,49,0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      line-height: 1.3;
      pointer-events: none;          /* prevents blocking hover */
      transition: opacity 120ms ease, transform 120ms ease;
      transform-origin: left top;
      opacity: 0;
    }
    
    #vg-tooltip-element.visible {
      visibility: visible;
      opacity: 1;
      transform: translate3d(0,0,0) scale(1);
    }
    
    #vg-tooltip-element.custom-theme,
    #vg-tooltip-element.custom-theme-theme,
    .custom-theme,
    .custom-theme-theme {
      background: linear-gradient(180deg, #fffdf3 0%, #fef3c7 100%);
      color: #111;
      border-color: rgba(34,40,49,0.08);
    }
  
    #vg-tooltip-element table {
      border-spacing: 0;
      width: 100%;
    }
    #vg-tooltip-element table tr { border: none; }
    #vg-tooltip-element table tr td { padding: 4px 6px; vertical-align: middle; }
    
    #vg-tooltip-element table tr td.key,
    #vg-tooltip-element .key {
      text-align: left;            
      font-weight: 700;
      color: #234a7a;                 /* deep stormy blue for keys */
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
        
    #vg-tooltip-element table tr td.value,
    #vg-tooltip-element .value {
      color: #0b6aa6;                 /* clear blue for values */
      font-weight: 600;
      text-align: right;
    }

    /* Page and container */
    html,body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; color:#111; }
    
    body {
      margin: 0;
      padding: 0;
      background-color: #e0e7ef; /* soft blue-gray background */
      background-repeat: repeat;
      background-size: auto;
      font-family: Helvetica, Arial, sans-serif;
      color: #111;
    }
    
    .poster {
      max-width: 1100px;
      margin: 0 auto;
      padding-left: 40px; 
      padding-right: 20px; 
      padding-top: 56px; 
      padding-bottom: 40px; 
      background-color: #f4f7fb; /* light grey poster background */
      box-shadow: 0 0 40px rgba(0,0,0,0.1);
      border-radius: 12px;
    }

    /* Inner content layout */
    .page {
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    /* Image at the top of the page */
    .opening-image {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    
    .opening-img {
      max-width: 640px;
      width: 80%;
      height: auto;
      display: block;
      border-radius: 6px;
    }

    /* Main page title */
    .page-title {
      font-size: 36px;
      font-weight: 700;
      color: #1f2a44; /* deep stormy blue */
      margin-bottom: 8px;
      text-align: center;
    }
    
    /* Subtitle under title */
    .page-subtitle {
      font-size: 20px;
      font-weight: 400;
      color: #4b5d7e; /* muted steel blue */
      margin-bottom: 24px;
      text-align: center;
    }
    
    .intro-paragraph {
      max-width: 700px;
      margin: 0 auto 32px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      text-align: center;
    }
    
    .highlight {
      color: #e07b39; /* weathered orange */
      font-weight: 600;
    }

    .viz-card {
      max-width: 1080px;
      margin-left: 1.5cm;
      margin-right: auto;
      position: relative;
    }
    
    .viz-title {
      font-size: 26px;
      font-weight: 700;
      color: #2c3e50; /* stormy navy */
      margin: 0 0 6px 0;
      text-align: left;
    }
    
    .viz-sub {
      font-size: 18px;
      color: #5c6e8c; /* steel blue-gray */
      margin: 0 0 16px 0;
      text-align: left;
    }

    .viz-embed { position: relative; }
    
    /* Overlay SVG for leader lines (on top of canvas/svg) */
    .viz-embed .annotation-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }
    
    .annotation-box {
      position: absolute;
      display: inline-block;          
      transform: translate(0, 0);
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(34,40,49,0.08);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      font-family: "Merriweather", Georgia, "Times New Roman", serif;
      font-size: 14px;
      color: #1f2a44;
      max-width: 320px;         
      white-space: normal;          
      line-height: 1.25;
      pointer-events: auto;
      z-index: 9999;
      height: auto;
      width: auto; 
    }
    
    .annotation-box .annotation-label {
      font-weight: 700;
      letter-spacing: -0.2px;
      color: #123047;
    }
    
    .annotation-box .caption {
      display: block;
      margin-top: 6px;
      color: #55607a;
      font-size: 12px;
      font-weight: 500;
    }
    
    .annotation-line { stroke: #000000; stroke-width: 1.6px; stroke-linecap: round; opacity: 0.95; }

    .row { display:flex; gap:16px; align-items:flex-start; justify-content:center; }
    .col { flex:1; min-width:280px; max-width:620px; }

    @media (max-width: 900px) {
      .row { flex-direction: column; }
    }

    /* header block that matches viz-left width and centering */
    .viz-header { display:flex; justify-content:flex-start; margin-bottom:8px; }
    .viz-title-block { width:100%; max-width:840px; box-sizing:border-box; }
    .viz-title, .viz-sub { margin:0; padding:0; }

    /* container that centers the chart+legend group */
    .viz-legend-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 12px;              /* small gap between viz and legend */
      padding: 12px 0;
      
    }

    .viz-left {
      max-width: 100%;
      position: relative;
      box-sizing: border-box;
    }
    
    /* Ensure embed fills the left column */
    .viz-left .viz-embed,
    .viz-embed {
      width: 100% !important;
      max-width: 100% !important;
      height: auto;
    }
    
    .legend-right { 
      position: static !important; 
      top: auto !important; 
      right: auto !important; 
      z-index: auto !important; 
    }
    
    .size-legend {
      padding: 8px 10px;
      background: rgba(255,255,255,0.96);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      border: 1px solid rgba(34,40,49,0.08);
      max-width: 300px;
    }
    
    @media (max-width: 880px) {
      .viz-legend-wrapper { flex-direction: column; align-items: center; }
      .legend-right { margin-left: 0; margin-top: 12px; }
    }

    .map-stack-left {
      flex: 0 1 auto;
      min-width: 320px;
      max-width: 840px;     
      display: block;
    }
    
    .map-stack-left .map-stack-item {
      margin-bottom: 18px;
      width: 100%;
      box-sizing: border-box;
    }
    
    .map-stack-left .viz-embed {
      width: 840px;      
      max-width: 100%;
    }

    // ----------------------------
    // Country legend style
    // ----------------------------

    #country-legend-swatches,
    #deadliest-country-swatches {
      display: flex !important;
      flex-direction: column !important;
      gap: 6px !important;        
      margin-top: 8px !important;
      padding: 0 !important;
      box-sizing: border-box !important;
    }
    
    #country-legend-swatches .f-row,
    #deadliest-country-swatches .f-row {
      display: flex !important;
      align-items: center !important;
      gap: 8px !important;
      font-size: 13px !important; 
      color: #123047 !important;
      padding: 0 !important;
      min-height: 20px !important;
      box-sizing: border-box !important;
    }
    
    #country-legend-swatches .swatch,
    #deadliest-country-swatches .swatch {
      width: 24px !important;
      height: 14px !important;
      border-radius: 3px !important;
      border: 1px solid rgba(0,0,0,0.08) !important;
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06) !important;
      margin-right: 0 !important;
      flex: 0 0 auto !important;
      display: inline-block !important;
    }
    
    #country-legend-swatches .f-label,
    #deadliest-country-swatches .f-label {
      flex: 0 0 auto !important;
      font-weight: 700 !important;
      font-family: Inter, sans-serif !important;
      line-height: 1 !important;
      color: inherit !important;
    }
    
    #country-legend-swatches .f-desc,
    #deadliest-country-swatches .f-desc {
      color: #55607a !important;
      font-weight: 500 !important;
      margin-left: 6px !important;
      font-size: 13px !important;
    }
    
    // ----------------------------
    // Fujita rating legend styles
    // ----------------------------

    .fujita-legend {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
    }
    
    .fujita-legend .f-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #123047;
    }
    
    .fujita-legend .swatch {
      width: 24px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06);
      flex: 0 0 auto;
    }
    
    .fujita-legend .f-label {
      flex: 0 0 auto;
      font-weight: 700;
    }
    
    .fujita-legend .f-desc {
      color: #55607a;
      font-weight: 500;
      margin-left: 6px;
    }

    .legend-item.disabled { opacity: 0.45; }
    .legend-item .legend-checkbox {
      margin-right: 8px;
      box-sizing: border-box;
    }
    
    .legend-checkbox[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      min-width: 16px;
      min-height: 16px;
      margin: 0;
      padding: 0;
      background-color: #fff;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 3px;
      box-sizing: border-box;
      display: inline-block;
      vertical-align: middle;
      position: relative;          
      line-height: 16px;         
      font-size: 14px;            
      text-align: center;       
      cursor: pointer;
    }
    
    .legend-checkbox[type="checkbox"]:checked::after {
      content: "✓";
      color: #123047;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%); 
      font-size: 12px;                  
      line-height: 1;
      pointer-events: none;
    }
    
    .legend-checkbox[type="checkbox"]:focus {
      outline: 2px solid rgba(18,48,71,0.12);
      outline-offset: 2px;
    }
    
    .legend-nudge {
      margin-left: 16px;
    }

    #fujita-static-swatches,
    #fujita-legend {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
      padding: 0;
      box-sizing: border-box;
    }
    
    #fujita-static-swatches .f-row,
    #fujita-legend .f-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #123047;
      padding: 0;
      min-height: 20px;   
      box-sizing: border-box;
      margin: 0;             
      line-height: 1;      
    }
    
    #fujita-static-swatches .swatch,
    #fujita-legend .swatch {
      width: 24px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06);
      margin-right: 0;
      flex: 0 0 auto;
      display: inline-block;
    }
    
    #fujita-static-swatches .f-label,
    #fujita-legend .f-label {
      flex: 0 0 auto;
      font-weight: 700;
      line-height: 1;
    }
    #fujita-static-swatches .f-desc,
    #fujita-legend .f-desc {
      color: #55607a;
      font-weight: 500;
      margin-left: 6px;
      font-size: 13px;
    }
    
    #fujita-legend .legend-checkbox,
    #fujita-static-swatches .legend-checkbox {
      margin: 0;
      padding: 0;
      width: 16px;
      height: 16px;
      box-sizing: border-box;
      vertical-align: middle;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    // ----------------------------
    // El Reno
    // ----------------------------
    
    .el-reno-block {
      max-width: 1080px;
      margin-left: 1.5cm;     
      margin-right: auto;
      box-sizing: border-box;
      padding-bottom: 64px; 
    }
    
    .el-reno-image-row {
      margin-bottom: 18px;
    }
    
    .el-reno-image-row .el-reno-figure {
      width: 850px;
      margin: 0;
      box-sizing: border-box;
    }
    .el-reno-image-row .el-reno-figure img {
      width: 850px;
      height: auto;
      display: block;
    }
    
    .el-reno-two-col {
      display: grid;
      grid-template-columns: 320px 1fr;
      column-gap: 75px;
      align-items: center;
      box-sizing: border-box;
      width: 840px;             /* match image width */
      max-width: 100%;
      padding-left: 0;          /* remove extra left inset */
      margin: 0;
    }
    
    .el-reno-left {
      display: flex;
      flex-direction: column;
      align-items: center;     
      gap: 8px;      
      align-items: stretch; 
      box-sizing: border-box;
      text-align: center;
    }

    .el-reno-left .el-reno-narrow {
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      text-align: center;
      max-width: 700px;
      margin: 0 auto;
    }
    
    .el-reno-left .viz-title,
    .el-reno-left .viz-sub {
      width: 100%;
      margin: 0;
      text-align: center;
    }

    .viz-title {
      font-size: 26px;
    }
    
    .viz-sub {
      font-size: 18px;
    }
    
    .el-reno-left .viz-sub {
      margin-bottom: 6px;
      color: #55607a;
      font-size: 18px;
      line-height: 1.35;
    }
    
    .el-reno-right {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      min-height: 480px;
      box-sizing: border-box;
    }
    
    #viz-el-reno-hodograph.viz-embed,
    #viz-el-reno-hodograph.viz-embed > svg,
    #viz-el-reno-hodograph.viz-embed > div,
    #viz-el-reno-hodograph.viz-embed iframe {
      display: block !important;
      width: 480px !important;
      height: 480px !important;
      margin: 0 !important;
      box-sizing: border-box !important;
    }

    #viz-el-reno-hodograph.viz-embed {
      position: relative;
    }
    
    .el-reno-right .el-reno-legend-box {
      position: absolute;
      left: calc(480px + 12px);
      top: 0;
      width: 112px;
      padding: 6px;
      background: rgba(255,255,255,0.98);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      border: 1px solid rgba(34,40,49,0.08);
      box-sizing: border-box;
      z-index: 50;
    }
    .el-reno-right .el-reno-legend-box .legend-title {
      font-size: 12px;
      font-weight: 700;
      margin-bottom: 6px;
    }
    .el-reno-right .el-reno-legend-box #el-reno-order-swatches,
    .el-reno-right .el-reno-legend-box #el-reno-order-swatches svg {
      width: 64px !important;
      height: auto !important;
      display: block !important;
    }
    
    .el-reno-two-col > * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    .el-reno-two-col :not(.annotation-box) {
      box-sizing: border-box;
    }

    @media (max-width: 980px) {
      .el-reno-block,
      .el-reno-image-row .el-reno-figure,
      .el-reno-two-col {
        width: 100%;
        margin-left: 0;
      }
      .el-reno-image-row .el-reno-figure img {
        width: 100%;
        height: auto;
      }
      .el-reno-two-col {
        display: block;
        padding-left: 0;
      }
      .el-reno-left,
      .el-reno-right {
        min-height: auto;
        padding-left: 0;
      }
      #viz-el-reno-hodograph.viz-embed,
      #viz-el-reno-hodograph.viz-embed > svg,
      #viz-el-reno-hodograph.viz-embed > div,
      #viz-el-reno-hodograph.viz-embed iframe {
        width: 100% !important;
        height: auto !important;
      }
      .el-reno-right .el-reno-legend-box {
        position: static;
        left: auto;
        top: auto;
        width: 100%;
        margin-top: 8px;
      }
    }

    #viz-el-reno-hodograph.viz-embed {
      position: relative !important;
      padding: 0 !important;
      margin: 0 !important;
      overflow: visible !important;
      box-sizing: border-box !important;
    }
    
    #viz-el-reno-hodograph.viz-embed > .annotation-box,
    #viz-el-reno-hodograph.viz-embed .annotation-box {
      position: absolute !important;
      display: inline-block !important;
      width: auto !important;
      min-width: 0 !important;
      max-width: 320px !important;
      height: auto !important;
      padding: 8px 10px !important;
      box-sizing: border-box !important;
      white-space: normal !important;
      overflow: visible !important;
      transform: translate(0,0) !important;
      background: rgba(255,255,255,0.96) !important;
      border: 1px solid rgba(34,40,49,0.08) !important;
      border-radius: 8px !important;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06) !important;
      font-size: 14px !important;
      line-height: 1.25 !important;
    }
    
    #viz-el-reno-hodograph.viz-embed > * {
      align-self: start !important;
      min-height: 0 !important;
    }

    .spacer-32 { height: 32px; width: 100%; display: block; }
    
    .footer-metadata {
      font-size: 13px;
      color: #5c6e8c; /* soft steel grey */
      line-height: 1.5;
      margin-top: 48px; /* visual gap above */
      margin-bottom: 24px;
      max-width: 840px;

      /* Consistency Styles */

      .viz-header {
        display: flex;
        align-items: flex-start;
        gap: 12px;
      }
      
      .viz-title-block { display: block; }
      
      .viz-title,
      .viz-sub {
        display: block;    
        margin: 0;          
        padding: 0;
        line-height: 1.15; 
        text-align: left;
      }
      
      .viz-title { margin-bottom: 6px; font-size: 26px; font-weight: 700; color: #2c3e50; }
      .viz-sub   { margin-bottom: 12px; font-size: 18px; color: #5c6e8c; }
      
      .viz-embed,
      .viz-embed > svg,
      .size-legend svg,
      .viz-legend-wrapper svg {
        display: block;
        vertical-align: top; 
      }
      
      .viz-legend-wrapper {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        padding: 12px 0;
      }
      
      .viz-card > h3.viz-title + p.viz-sub,
      .viz-card .viz-title-block > h3.viz-title + p.viz-sub {
        margin-top: 6px;
      }
    }
    
  </style>
</head>
<body>
  <div class="poster">
    <div class="page">
      
      <div class="opening-image" aria-hidden="false" role="img" aria-label="Tornado illustration">
        <img src="tornado.jpg" alt="Tornado" class="opening-img" />
      </div>
      
      <h1 class="page-title">Tornadoes Down Under and Across the Plains</h1>
      <h2 class="page-subtitle">Most people picture the U.S. when they hear “tornado.”<br/>
        Australia, however, records roughly 100 tornadoes annually.
      </h2>
      
      <p class="intro-paragraph">
        Tornadoes are one of the most <span class="highlight">violent</span> weather phenomena.<br/>
        They form under specific conditions: instability, moisture, and a lifting mechanism.<br/>
        Australia’s geography and climate make it <span class="highlight">ripe for severe storms</span>.<br/>
        Despite lower frequency than the U.S., tornadoes here can<br/>
        still be <span class="highlight">large and dangerous</span>.<br/><br/>
        This visualisation explores their patterns, strength, and impact.<br/>

        Hover over points in each visualisation<br/>
        to reveal <span class="highlight">detailed values</span> and contextual information.<br/>
        Use the map below to find <span class="highlight">tornado hotspots</span><br/>
        across Australia, note regions with the <span class="highlight">highest counts</span><br/>
        and compare their <span class="highlight">relative frequency</span>.
      </p>
  
      <!-- 1) tornado_density_across_australia -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornado density across Australia between 1900 and 2025</h3>
            <p class="viz-sub">Aggregated by 3 degree bins and scaled by frequency</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-tornado-density" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="tornado-size-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Tornado count</div>
              <svg id="tornado-size-legend-svg" role="img" aria-label="Tornado count legend"></svg>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        From the above map we can see that much of<br/>
        Australia experiences <span class="highlight">tornadoes</span>.<br/>
        It is likely that Australia experiences many tornadoes<br/>
        that <span class="highlight">go unnoticed</span> due to large unpopulated regions.
      </p>

      <p class="intro-paragraph">
        The <span class="highlight">Bureau of Meteorology (BOM)</span> maintains a severe weather repository.<br/>
        These events typically come from <span class="highlight">structured storms</span>, which cause<br/>
        damage to <span class="highlight">houses, trees and infrastructure.</span> This visualisation focuses<br/>
        on <span class="highlight">rain, hail and tornado</span> events.<br/>
        See the <span class="highlight">relative prevalence</span> of these events<br/>
        by <span class="highlight">state</span> in the chart below.
      </p>

      <!-- 2) severe_weather_proportions_per_state -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Severe weather distribution between 1900 and 2025 by Australian states</h3>
            <p class="viz-sub">ACT was excluded due to its small data size</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-severe-proportions" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="severe-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Severe weather</div>
              <svg id="severe-legend-svg" width="200" height="140" role="img" aria-label="Severe weather legend"></svg>
            </div>
          </div>
        </div>
      </section>
            
      <p class="intro-paragraph">
        The <span class="highlight">Fujita rating</span> links damage to wind speed.<br/>
        Dr. Tetsuya Fujita introduced the idea in 1971.<br/>
        Working at the University of Chicago, he reimagined tornado study.<br/>
        The scale let researchers infer winds where direct measures were impossible.<br/>
        Tornado research most often centres on the United States.<br/>
        That region’s storms produced the data to shape the scale.<br/>
        The original scale runs from <span class="highlight">F0 to F5</span>.<br/><br/>
        In 2007 the <span class="highlight">Enhanced Fujita</span> refined those categories.<br/>
        It ties specific damage types to narrower wind ranges.<br/>
        For example, destruction of mobile homes implies winds above 180 km/h.<br/>
        That observable damage becomes a forensic clue to peak winds.<br/>
        The Fujita approach turns wreckage into repeatable science.<br/>
        It remains central to how we understand tornado strength today.
      </p>
  
      <!-- 3+4) dynamic maps row: Australian and US maps (vertically placed) -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornadoes by Fujita rating between 2010 and 2014</h3>
            <p class="viz-sub">Toggle ratings using the checkboxes below. Inspect the locations that experienced the most tornadoes and the most severe tornadoes</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left map-stack-left">
            <div id="aus-chart" class="viz-embed map-stack-item" aria-label="Australia tornado map"></div>
            <div id="us-chart" class="viz-embed map-stack-item" aria-label="United States tornado map"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Map legend and controls">
            <div id="combined-rating-legend" class="size-legend" role="group" aria-label="Fujita rating legend">
              <div class="legend-title">Fujita rating</div>
              <div id="legend-checkboxes" aria-label="Fujita rating toggles" role="list"></div>
              <div id="fujita-legend" class="fujita-legend" role="list" aria-label="Fujita scale colours"></div>
              <div class="legend-note" style="margin-top:8px; color:#55607a; font-size:12px;">
                Toggle ratings to show or hide that class on the maps.
              </div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Dense clusters show tornadoes are common in the U.S.<br/>
        Use the time series below to see annual tornado counts.<br/>
        Stacked areas break tornadoes down by <span class="highlight">Fujita rating</span>.<br/>
        See how each strength class has shifted over time.<br/>
        Combined height shows the <span class="highlight">total count</span> each year.
      </p>

      <!-- 5) tornadoes_by_fujita_rating_and_year -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">The number of recorded tornadoes in the U.S. since 1950</h3>
            <p class="viz-sub">The values are broken down by fujita rating</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-total-tornadoes" class="viz-embed"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Fujita scale legend">
            <div id="fujita-static-legend" class="size-legend" role="group" aria-label="Fujita scale colours">
              <div class="legend-title">Fujita Rating</div>
              <div id="fujita-static-swatches" class="fujita-legend" role="list" aria-label="Fujita scale colours"></div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Whilst Australia obviously experiences <span class="highlight">far fewer servere tornado events</span><br/>
        than the United States, we still experience strong tornadoes<br/>
        with the fastest being <span class="highlight">F4 rated</span>.<br/><br/>
        As noted before. Wind speeds are <span class="highlight">estimated based on damage</span>.<br/> 
        When the BOM is surveying tornado damage, they estimate the<br/>
        associated wind strength. Use the time sliders in the<br/>
        below visualisation to see the <span class="highlight">fastest tornadoes</span><br/>
        in a given period.
      </p>
  
      <!-- 6) fastest_australian_tornadoes -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Top Five Fastest Tornadoes by Wind Speed Since 1900 in Australia</h3>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-fastest-aus" class="viz-embed"></div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Tornadoes are <span class="highlight">very seasonal events</span> that require a <span class="highlight">lifting mechanism</span>,<br/>
        a <span class="highlight">moist atmosphere</span>, and <span class="highlight">conditional instability</span> to develop.<br/>
        For this reason, <span class="highlight">spring</span> is the most common season,<br/>
        though tornadoes can occur year-round. Below are monthly<br/>
        distributions for <span class="highlight">Australia</span> (Southern Hemisphere) and the<br/>
        <span class="highlight">United States</span> (Northern Hemisphere). Values show the<br/>
        <span class="highlight">proportion</span> of tornadoes occurring each month in both countries.
      </p>

      <!-- 7) tornadoes_by_month_aus_vs_us -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornadoes by month — Australia vs U.S.</h3>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-by-month" class="viz-embed"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="country-legend" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="country-legend-swatches" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>
        
      <p class="intro-paragraph">
        With <span class="highlight">wind speeds high enough to shred</span><br/>
        a well-built house off its foundations,<br/>
        tornadoes have sadly <span class="highlight">claimed many lives</span>.<br/>
        See below a chart of some of the<br/>
        <span class="highlight">deadliest tornadoes of all time</span>.
      </p>
  
      <!-- 8) deadliest_tornadoes_bubble_chart -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Worldwide deadliest tornado events by date, fatality count and country</h3>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-deadliest-bubble" class="viz-embed"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="deadliest-country-legend" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="deadliest-country-swatches" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        See the general locations of these deadliest<br/>
        tornado events visualised on a worldmap.<br/>
        However, <span class="highlight">Bangladesh</span> has experienced the <span class="highlight">most deadly storms</span>.
      </p>
   
      <!-- 9) deadliest_tornadoes_on_a_map -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Location of world's deadliest tornado events</h3>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-deadliest-map" class="viz-embed"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="deadliest-country-legend-map" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="deadliest-country-swatches-map" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        After reviewing the deadliest storms, we zoom in on a single event.<br/>
        The focus is the <span class="highlight">2013 El Reno tornado</span> in Oklahoma.<br/>
        We examine how near‑storm wind conditions and shear shape tornado behaviour.<br/>
        This case shows how atmospheric profiles translate into storm intensity and damage.
      </p>

      <!-- 10) El-reno example -->
      <section class="viz-card el-reno-block" aria-labelledby="el-reno-title">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 id="el-reno-title" class="viz-title">El Reno Tornado — profile and hodograph</h3>
          </div>
        </div>
      
        <div class="el-reno-image-row">
          <figure class="el-reno-figure">
            <img src="el-reno.jpg" alt="El Reno tornado, May 2013" loading="lazy">
            <figcaption class="el-reno-caption">The El Reno tornado, May 2013 — one of the largest observed.</figcaption>
          </figure>
        </div>
      
        <div class="el-reno-two-col" role="region" aria-label="El Reno text and hodograph">
          <div class="el-reno-left">
            <h4 class="viz-section-title">Wind direction and speed mapped over altitude</h4>
            <p class="viz-sub">The speed was calculated at Oklahoma City,<br/>approximately when the storm was passing through</p>
      
            <p class="el-reno-narrow">
              Wind shear that <span class="highlight">turns</span> and <span class="highlight">increases</span> with height
              helps create the rotation seen in the hodograph. The final sounding after the tornado shows strong
              low‑level curvature and speed increases, indicating streamwise vorticity being tilted into the updraft.
            </p>
          </div>
      
          <div class="el-reno-right">
            <div id="viz-el-reno-hodograph" class="viz-embed" aria-label="El Reno hodograph"></div>
      
            <div class="el-reno-legend-box" aria-hidden="false">
              <div class="legend-title">Altitude (m)</div>
              <div id="el-reno-order-swatches" class="fujita-legend" role="list" aria-label="Altitude colours"></div>
            </div>
          </div>
        </div>
      </section>
    </div>

    <div class="spacer-32"></div>

    <p class="intro-paragraph">
      In conclusion, <span class="highlight">tornadoes affect both Australia and the U.S.</span><br/>
      Yet the <span class="highlight">United States remains the global center</span><br/>
      for <span class="highlight">tornado frequency</span> and <span class="highlight">storm intensity</span>.<br/>
      Tornadoes show a <span class="highlight">strong seasonal pattern</span> in both nations.<br/>
      <span class="highlight">Wind shear</span> and <span class="highlight">supercell storms</span> drive the most violent events.<br/>
      Australia faces <span class="highlight">fewer but dangerous tornadoes</span> across wide regions.<br/>
      The U.S. experiences <span class="highlight">more frequent and powerful outbreaks</span>.<br/>
      These patterns reveal <span class="highlight">key risks and dynamics</span> worldwide.<br/>
      Understanding them supports <span class="highlight">better safety</span> and <span class="highlight">preparedness</span>.<br/>
    </p>
        
    <hr class="section-separator" aria-hidden="true">
        
    <p class="footer-metadata">
      Created by James Talbot<br>
      Licensed under Creative Commons Attribution 4.0<br><br>
    
      Image 1 Source: https://shelterbox.org/disasters-explained/tornadoes/<br>
      Image 2 Source: https://inside.nssl.noaa.gov/nsslnews/2015/07/significant-paper-kuster-c-m-heinselman-p-l-austin-m/<br><br>
    
      The images have been used under fair use.<br><br>
    
      Data sources:<br>
      – Australian tornado data: https://www.bom.gov.au/australia/stormarchive/<br>
      – U.S. tornado data: https://www.ncei.noaa.gov/stormevents/ftp.jsp<br>
      – Deadliest tornado data: https://www.discoverwalks.com/blog/world/25-deadliest-tornadoes-in-recorded-history/<br>
      – Hodograph data: https://weather.uwyo.edu/upperair/sounding.shtml<br>
      – Map data: https://www.naturalearthdata.com/downloads/<br>

      <strong>AI Acknowledgement</strong><br>
      Copilot has been used when constructing the vega-lite json file as well as the index.html file.<br>
      The LLM was utilised to expedite the process of forming the index.html file.<br>
      Specific CSS styles were employed to add the specific character of the chart.<br>
      Additionally, the generative AI was used to help create and fix functions that embedded annotations on charts, and dynamically generate a pre-defined vega-lite schema.<br>
      I wrote base code and then refined it with Copilot.<br>
      I was then able to quickly specify things that needed changing and use the LLM’s output to improve the code.
    </p>
    
  </div>

  <script>
    // ------------------------
    // Configuration
    // ------------------------

    // JSON spec filenames
    const specs = {
      tornadoDensity: "tornado_density_across_australia.json",
      severeProportions: "severe_weather_proportions_per_state.json",
      fastestAus: "fastest_australian_tornadoes.json",
      totalTornadoes: "tornadoes_by_fujita_rating_and_year.json",
      byMonth: "tornadoes_by_month_aus_vs_us.json",
      deadliestBubble: "deadliest_tornadoes_bubble_chart.json",
      deadliestMap: "deadliest_tornadoes_on_a_map.json",
      elRenoHodograph: "el-reno_hodograph.json",
    };

    const csvRepoBase = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/";

    const ausCsvPattern = csvRepoBase + "Tornado_F{R}_2010_2024_Australia.csv";
    const usCsvPattern  = csvRepoBase + "Tornado_F{R}_2010_2024_America.csv";

    const ausBaseTopo = csvRepoBase + "australia.json";
    const ausGraticules = csvRepoBase + "10_degree_graticules_for_australia.json";

    const usBaseTopo = csvRepoBase + "mainland_united_states.json";
    const usGraticules = csvRepoBase + "10_degree_graticules_for_united_states.json";

    // Fujita rating colours and list (initial selection: all)
    const ratingColors = {
      "F0": "#999999",
      "F1": "#E69F00",
      "F2": "#56B4E9",
      "F3": "#009E73",
      "F4": "#FFD166",
      "F5": "#984ea3"
    };
    const ratings = ["F0","F1","F2","F3","F4","F5"];
    let selectedRatings = new Set(ratings);

    // Latitude/longitude field names in the CSVs
    const ausLatField = "Latitude";
    const ausLonField = "Longitude";
    const usLatField = "BEGIN_LAT";
    const usLonField = "BEGIN_LON";

    // ------------------------
    // Helpers
    // ------------------------

    async function embedSpec(target, urlOrSpec) {
      try {
        await vegaEmbed(target, urlOrSpec, { 
          actions: false, 
          renderer: "canvas",
          tooltip: { 
            theme: 'custom',
            disableDefaultStyle: true
          }
        });
      } catch (err) {
        document.querySelector(target).innerHTML = "<div style='padding:12px;color:#900;'>Failed to render: " + (err.message || err) + "</div>";
        console.error("Embed error", err);
      }
    }

    async function fetchCsv(url) {
      try {
        const r = await fetch(url);
        if (!r.ok) return [];
        const text = await r.text();
        const lines = text.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const cols = lines[0].split(",");
        const rows = [];
        for (let i=1;i<lines.length;i++){
          const vals = lines[i].split(",");
          const obj = {};
          for (let j=0;j<cols.length;j++){
            obj[cols[j]] = vals[j] !== undefined ? vals[j] : "";
          }
          rows.push(obj);
        }
        return rows;
      } catch (e) {
        console.warn("CSV fetch failed", url, e);
        return [];
      }
    }

    // ------------------------
    // Creating legends 
    // ------------------------

    function drawTornadoSizeLegend(containerId = "tornado-size-legend-svg") {
      const domain = [1, 160];
      const rangeArea = [50, 840]; // same as Vega-Lite size scale (area in px^2)
      const counts = [150, 100, 30, 1]; // draw largest first (this equates to being on the highest layer)
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // helpers
      const areaForCount = c => {
        const t = (c - domain[0]) / (domain[1] - domain[0]);
        return rangeArea[0] + t * (rangeArea[1] - rangeArea[0]);
      };
      const radiusForArea = a => Math.sqrt(a / Math.PI);
    
      // clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      // layout params
      const paddingLeft = 12;
      const paddingTop = 12;
      const itemGap = 12;         
      const labelGap = 8;     
      const labelFontSize = 12;
    
      const radii = counts.map(c => radiusForArea(areaForCount(c)));
      const maxR = Math.max(...radii);
      const circleColWidth = Math.ceil(2 * maxR);
      const labelColWidth = 70;               
    
      // initial positions
      let y = paddingTop;
    
      counts.forEach((c, i) => {
        const r = radii[i];
        const cx = paddingLeft + maxR; // center circles in left column
        const cy = y + r;
    
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", cx);
        circ.setAttribute("cy", cy);
        circ.setAttribute("r", r);
        circ.setAttribute("fill", "#0072B2");
        circ.setAttribute("fill-opacity", "0.85");
        circ.setAttribute("stroke", "#fff");
        circ.setAttribute("stroke-width", "1");
        svg.appendChild(circ);
    
        // label to the right of the circle
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + circleColWidth + labelGap);
        label.setAttribute("y", cy + (labelFontSize / 3)); // vertically align text near center
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.textContent = String(c);
        svg.appendChild(label);
    
        // advance y for next item: circle diameter + gap
        y += Math.ceil(2 * r + itemGap);
      });
    
      const totalWidth = paddingLeft + circleColWidth + labelGap + labelColWidth + 12;
      const totalHeight = y + 8;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function drawSevereLegendVertical(containerId = "severe-legend-svg") {
      // colour mapping (matches the predefined glyph colours)
      const items = [
        { key: "rain_mentions", label: "Rain", color: "#0072B2" },
        { key: "hail_mentions", label: "Hail", color: "#009E73" },
        { key: "tornado_mentions", label: "Tornado", color: "#D55E00" }
      ];
    
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      const paddingLeft = 12;
      const paddingTop = 12;
      const swatchSize = 18;   
      const itemGap = 14;      
      const labelGap = 10;    
      const labelFontSize = 12;
    
      // clear existing content
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      let y = paddingTop;
    
      items.forEach((it, i) => {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", paddingLeft);
        rect.setAttribute("y", y);
        rect.setAttribute("width", swatchSize);
        rect.setAttribute("height", swatchSize);
        rect.setAttribute("rx", 3);
        rect.setAttribute("ry", 3);
        rect.setAttribute("fill", it.color);
        rect.setAttribute("stroke", "#fff");
        rect.setAttribute("stroke-width", "1");
        svg.appendChild(rect);
    
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + swatchSize + labelGap);
        label.setAttribute("y", y + swatchSize - 4);
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.setAttribute("class", "severe-legend-swatch-label");
        label.textContent = it.label;
        svg.appendChild(label);
    
        y += swatchSize + itemGap;
      });
    
      const totalWidth = paddingLeft + swatchSize + labelGap + 80;
      const totalHeight = y + 6;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function makeLegendRows(container, items, colors, opts = {}) {
      const swW = opts.swatchWidth || 24;
      const swH = opts.swatchHeight || 14;
      if (!container) return;
    
      container.innerHTML = "";
      container.style.display = "flex";
      container.style.flexDirection = "column";
      container.style.gap = "6px";
      container.style.marginTop = "8px";
      container.style.boxSizing = "border-box";
    
      items.forEach(labelText => {
        const row = document.createElement("div");
        row.className = "f-row";
        row.setAttribute("role", "listitem");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.fontSize = "13px";
        row.style.color = "#123047";
        row.style.padding = "0";
        row.style.minHeight = "20px";
        row.style.boxSizing = "border-box";
    
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.width = swW + "px";
        sw.style.height = swH + "px";
        sw.style.background = colors[labelText] || "#999";
        sw.style.borderRadius = "3px";
        sw.style.border = "1px solid rgba(0,0,0,0.08)";
        sw.style.boxShadow = "inset 0 -1px 0 rgba(0,0,0,0.06)";
        sw.style.display = "inline-block";
        sw.setAttribute("aria-hidden", "true");
    
        const label = document.createElement("span");
        label.className = "f-label";
        label.textContent = labelText;
        label.style.fontWeight = "700";
        label.style.fontFamily = "Inter, sans-serif";
        label.style.lineHeight = "1";
        label.style.display = "inline-block";
    
        row.appendChild(sw);
        row.appendChild(label);
        container.appendChild(row);
      });
    }
    
    function drawCountryLegend(containerId = "country-legend-swatches") {
      const container = document.getElementById(containerId);
      if (!container) return;
      const countries = ["Australia", "U.S."];
      const countryColors = { "Australia": "#CC79A7", "U.S.": "#56B4E9" };
      makeLegendRows(container, countries, countryColors, { swatchWidth: 24, swatchHeight: 14 });
    }
    
    function drawDeadliestCountryLegend(containerId = "deadliest-country-swatches") {
      const container = document.getElementById(containerId);
      if (!container) return;
      const countries = ["Bangladesh","United States","Russia","Italy","Malta","Argentina","Australia"];
      const countryColors = {
        "Bangladesh": "#E69F00",
        "United States": "#56B4E9",
        "Russia": "#009E73",
        "Italy": "#F0E442",
        "Malta": "#0072B2",
        "Argentina": "#D55E00",
        "Australia": "#CC79A7"
      };
      makeLegendRows(container, countries, countryColors, { swatchWidth: 24, swatchHeight: 14 });
    }
    
    // ------------------------
    // Adding annotations
    // ------------------------

    /* Charts */

    async function embedWithHtmlAnnotationsForCartesian(target, specUrlOrObject, options = {}) {
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = Object.assign({
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      }, options.embedOptions || {});
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
      if (view && typeof view.runAsync === "function") await view.runAsync();
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function getScaleFn(scaleName) {
        try {
          if (!view || typeof view.scale !== "function") return null;
          const s = view.scale(scaleName);
          if (typeof s !== "function") return null;
          return s;
        } catch (e) {
          return null;
        }
      }
    
      function dataToPixels(xVal, yVal) {
        const xScale = getScaleFn('x') || getScaleFn('xscale') || getScaleFn('xscale0') || null;
        const yScale = getScaleFn('y') || getScaleFn('yscale') || getScaleFn('yscale0') || null;
        const px = xScale ? xScale(xVal) : null;
        const py = yScale ? yScale(yVal) : null;
        return { x: px, y: py };
      }
    
      function toPixelPoint(pt, chartOffset = { left: 0, top: 0 }) {
        if (!pt) return null;
        // if coords explicitly 'px' assume already pixel coords
        if (pt.coords === "px") return { x: pt.x + (chartOffset.left || 0), y: pt.y + (chartOffset.top || 0) };
        // otherwise treat as data coords
        if (typeof pt.x === "number" && typeof pt.y === "number") {
          const p = dataToPixels(pt.x, pt.y);
          if (p.x == null || p.y == null) return null;
          return { x: p.x + (chartOffset.left || 0), y: p.y + (chartOffset.top || 0) };
        }
        return null;
      }
    
      function getChartOffset() {
        const containerRect = container.getBoundingClientRect();
        const canvas = container.querySelector("canvas");
        const svg = Array.from(container.querySelectorAll("svg")).find(s => !s.classList.contains("annotation-overlay"));
        const chartEl = canvas || svg || null;
        if (!chartEl) return { left: 0, top: 0 };
        const chartRect = chartEl.getBoundingClientRect();
        return {
          left: Math.round(chartRect.left - containerRect.left),
          top: Math.round(chartRect.top - containerRect.top)
        };
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        // compute chart element offset once per draw
        const chartOffset = getChartOffset();
          
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
        
        // create boxes first (so we can measure)
        const created = annotations.map(a => {
          // compute boxCoord (preferred)
          const boxCoord = (a.boxXY && typeof a.boxXY.x === "number" && typeof a.boxXY.y === "number") ? a.boxXY : null;
          if (!boxCoord) return null;
        
          // If boxCoord is in pixels, use it directly (container-relative).
          // If it's data coords, project via dataToPixels and then offset by chartOffset.
          let boxPxRaw;
          if (boxCoord.coords === "px") {
            boxPxRaw = { x: boxCoord.x, y: boxCoord.y };
          } else {
            const p = dataToPixels(boxCoord.x, boxCoord.y);
            if (!p || p.x == null || p.y == null) return null;
            boxPxRaw = { x: p.x + (chartOffset.left || 0), y: p.y + (chartOffset.top || 0) };
          }
          if (boxPxRaw.x == null || boxPxRaw.y == null) return null;
          const boxPx = { x: boxPxRaw.x, y: boxPxRaw.y };
        
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
          div.style.position = "absolute";
          div.style.pointerEvents = "auto";
        
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
        
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
        
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
        
          // default placement: box at boxPx + nudges
          let leftPx = boxPx.x + nudgeX;
          let topPx  = boxPx.y + nudgeY;
        
          // append off-DOM to measure size
          div.style.left = "-9999px";
          div.style.top = "-9999px";
          container.appendChild(div);
          const measured = div.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const w = Math.min(boxMaxWidth, measured.width);
          const h = measured.height;
        
          // adjust left/top to fit inside container bounds
          const margin = 8;
          if (leftPx + margin + w > width) leftPx = Math.max(margin, width - w - margin);
          if (leftPx < margin) leftPx = margin;
          if (topPx < margin) topPx = margin;
          if (topPx > height - 40) topPx = height - 40;
        
          div.style.left = Math.round(leftPx) + "px";
          div.style.top  = Math.round(topPx) + "px";
        
          return { a, div, left: leftPx, top: topPx, width: w, height: h, boxPx };
        }).filter(Boolean);
        
        // Helper to resolve a point (data or px) to pixel coords, container top-left = origin for px
        const resolvePoint = (pt) => {
          if (!pt) return null;
          if (pt.coords === "px") {
            // treat as container pixels (no chartOffset added)
            return { x: pt.x, y: pt.y };
          }
          if (typeof pt.x === "number" && typeof pt.y === "number") {
            const p = dataToPixels(pt.x, pt.y);
            if (p.x == null || p.y == null) return null;
            // project data coords and then offset by chartOffset so they align with DOM coords
            return { x: p.x + (chartOffset.left || 0), y: p.y + (chartOffset.top || 0) };
          }
          return null;
        };
        
        // draw lines according to explicit lineStart/lineEnd if present, otherwise skip anchor->box fallback
        created.forEach(c => {
          const ann = c.a;
        
          // If explicit lineStart/lineEnd provided, draw between those two points (user-controlled)
          const explicitStart = resolvePoint(ann.lineStart);
          const explicitEnd   = resolvePoint(ann.lineEnd);
          if (explicitStart && explicitEnd) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", Math.round(explicitStart.x));
            line.setAttribute("y1", Math.round(explicitStart.y));
            line.setAttribute("x2", Math.round(explicitEnd.x));
            line.setAttribute("y2", Math.round(explicitEnd.y));
            line.setAttribute("class", "annotation-line");
            line.setAttribute("stroke", (ann && typeof ann.lineColor === "string") ? ann.lineColor : "#000000");
            line.setAttribute("stroke-width", (ann && ann.lineWidth) ? String(ann.lineWidth) : "1.6");
            line.setAttribute("stroke-opacity", (ann && ann.lineOpacity) ? String(ann.lineOpacity) : "0.95");
            overlay.appendChild(line);
            return;
          }
        });
        return created;
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on resize or view updates
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
    
      // observe container size changes
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }
    
    /* Map annotations */
    
    async function embedWithHtmlAnnotations(target, specUrlOrObject, options = {}) {
      const projOpts = Object.assign({
        type: "mercator",
        center: [134, -28],
        scale: 850
      }, options.projection || {});
    
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = {
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      };
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
    
      if (view && typeof view.runAsync === "function") {
        await view.runAsync();
      }
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      // create/replace overlay SVG
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.setAttribute("preserveAspectRatio", "xMinYMin meet");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function makeProjection(width, height) {
        const vw = (view && typeof view.width === "function") ? view.width() : width;
        const vh = (view && typeof view.height === "function") ? view.height() : height;
        const geo = (typeof d3 !== "undefined" && typeof d3.geoMercator === "function") ? d3 : null;
        if (!geo) throw new Error("d3.geoMercator not available; include d3 (e.g. https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js)");
        return geo.geoMercator().center(projOpts.center).scale(projOpts.scale).translate([vw / 2, vh / 2]);
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        const proj = makeProjection(width, height);
        function projectPoint(lon, lat) {
          const p = proj([lon, lat]);
          return { x: p[0], y: p[1] };
        }
    
        // clear overlay contents and previous boxes
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
        // create boxes only (no lines or markers)
        const createdBoxes = annotations.map(a => {
          // prefer explicit boxLonLat for where the HTML box should sit
          const boxLon = (a.boxLonLat && typeof a.boxLonLat.lon === "number") ? a.boxLonLat.lon
                        : (a.src && typeof a.src.lon === "number" ? a.src.lon : null);
          const boxLat = (a.boxLonLat && typeof a.boxLonLat.lat === "number") ? a.boxLonLat.lat
                        : (a.src && typeof a.src.lat === "number" ? a.src.lat : null);
    
          // if we still don't have coords, skip this annotation
          if (boxLon === null || boxLat === null) return null;
    
          const boxPx = projectPoint(boxLon, boxLat);
    
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
    
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
    
          let left = Math.round(boxPx.x + container.scrollLeft + nudgeX);
          let top  = Math.round(boxPx.y + container.scrollTop + nudgeY);
    
          const containerRect = container.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const margin = 8;
    
          if (left + margin + boxMaxWidth > containerRect.width) left = Math.max(margin, containerRect.width - boxMaxWidth - margin);
          if (left < margin) left = margin;
          if (top < margin) top = margin;
          if (top > containerRect.height - 40) top = containerRect.height - 40;
    
          div.style.left = left + "px";
          div.style.top  = top + "px";
    
          container.appendChild(div);
    
          return {
            a,
            div,
            left,
            top,
            width: Math.min(boxMaxWidth, div.getBoundingClientRect().width),
            height: div.getBoundingClientRect().height,
            anchorPx: boxPx
          };
        }).filter(Boolean);
    
        // no leader lines or markers are created
        return createdBoxes;
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on window + container resize
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }

    // ------------------------
    // Dynamic maps (Australia and US) logic
    // ------------------------

    function drawFujitaColorLegend(containerId = "fujita-legend", opts = {}) {
      const container = document.getElementById(containerId);
      if (!container) return;
    
      const interactive = opts.interactive !== false; // default to true
      const descriptions = opts.descriptions || {
        "F0": "Gale damage",
        "F1": "Moderate damage",
        "F2": "Considerable damage",
        "F3": "Severe damage",
        "F4": "Devastating damage",
        "F5": "Incredible damage"
      };
    
      container.innerHTML = "";
    
      ratings.forEach(r => {
        const row = document.createElement("div");
        row.className = "f-row legend-item";
        row.setAttribute("role", "listitem");
        row.setAttribute("data-rating", r);
    
        if (interactive) {
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.className = "legend-checkbox";
          cb.value = r;
          cb.checked = selectedRatings.has(r);
          cb.setAttribute("aria-label", r + " toggle");
          cb.addEventListener("change", onLegendToggle);
          row.appendChild(cb);
    
          row.addEventListener("click", (e) => {
            if (e.target === cb) return;
            cb.checked = !cb.checked;
            cb.dispatchEvent(new Event("change", { bubbles: true }));
          });
    
          if (!cb.checked) row.classList.add("disabled");
        }
    
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = ratingColors[r] || "#ccc";
        sw.setAttribute("aria-hidden", "true");
    
        const label = document.createElement("span");
        label.className = "f-label legend-label";
        label.textContent = r;
    
        const desc = document.createElement("span");
        desc.className = "f-desc legend-desc";
        desc.textContent = descriptions[r] || "";
    
        row.appendChild(sw);
        row.appendChild(label);
        row.appendChild(desc);
    
        container.appendChild(row);
      });
    }

    function onLegendToggle(e) {
      const rating = e.target.value;
      const checked = e.target.checked;
      const item = e.target.closest(".legend-item");
      if (!item) return;
      if (!checked) {
        selectedRatings.delete(rating);
        item.classList.add("disabled");
      } else {
        selectedRatings.add(rating);
        item.classList.remove("disabled");
      }
      renderMaps(); // re-render maps with updated selectedRatings
    }

    async function renderMaps() {
      // build base layers
      const ausLayers = [
        {
          data: { url: ausBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: ausGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      const usLayers = [
        {
          data: { url: usBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: usGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      // gather per-rating point layers (only for selected ratings)
      for (const r of ratings) {
        if (!selectedRatings.has(r)) continue;

        const ausUrl = ausCsvPattern.replace("{R}", r.slice(1));
        const usUrl  = usCsvPattern.replace("{R}", r.slice(1));

        // fetch CSVs (graceful if missing)
        const [ausRows, usRows] = await Promise.all([fetchCsv(ausUrl), fetchCsv(usUrl)]);

        const ausValues = ausRows.map(row => {
          const out = Object.assign({}, row);
          if (out[ausLatField] !== undefined) out[ausLatField] = parseFloat(out[ausLatField]);
          if (out[ausLonField] !== undefined) out[ausLonField] = parseFloat(out[ausLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        const usValues = usRows.map(row => {
          const out = Object.assign({}, row);
          if (out[usLatField] !== undefined) out[usLatField] = parseFloat(out[usLatField]);
          if (out[usLonField] !== undefined) out[usLonField] = parseFloat(out[usLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        // push a point layer for this rating
        ausLayers.push({
          data: { values: ausValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: ausLonField, type: "quantitative" },
            latitude: { field: ausLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });

        usLayers.push({
          data: { values: usValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: usLonField, type: "quantitative" },
            latitude: { field: usLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
      } // end per-rating loop

      // Construct final specs
      const ausSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 840,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [134, -28], scale: 850 },
        layer: ausLayers,
        config: { view: { stroke: null } }
      };

      const usSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 840,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [-98, 38], scale: 750 },
        layer: usLayers,
        config: { view: { stroke: null } }
      };
      
      document.getElementById("aus-chart").innerHTML = "";
      document.getElementById("us-chart").innerHTML = "";
      
      // set spec widths consistent with CSS viz-left width (840)
      ausSpec.width = 840;
      usSpec.width = 840;
      
      await embedWithHtmlAnnotations("#aus-chart", ausSpec, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "alice-springs-note",
            boxLonLat: { lon: 128.5, lat: -22.5 },
            label: "Recorded tornadoes in central\nAustralia are extremely rare",
            nudgeX: -60,
            nudgeY: -10
          },
          {
            id: "wa-coast-note",
            boxLonLat: { lon: 116.0, lat: -36.5 },
            label: "Notice tornadoes cluster near populated areas; others may occur unrecorded offshore or remote inland",
            nudgeX: -180,
            nudgeY: 8
          }
        ]
      });

      await embedWithHtmlAnnotations("#us-chart", usSpec, {
        projection: { center: [-95, 37], scale: 900 },
        annotations: [
          {
            id: "ca-offshore-note",
            src: { lon: -119.0, lat: 30.0 },
            boxLonLat: { lon: -117.0, lat: 52.0 },
            label: "Tornadoes are less common in the western US but still occur",
            nudgeX: -12,
            nudgeY: -6,
            maxWidth: 320
          },
      
          {
            id: "southeast-note",
            src: { lon: -86.9, lat: 32.3 },
            boxLonLat: { lon: -90.5, lat: 25.0 },
            label: "Dangerous tornadoes are concentrated\nin the southeast states",
            nudgeX: -40,
            nudgeY: 10,
            maxWidth: 300
          }
        ]
      });
    }

    // apply to the outer-most legend column (the flex child that contains the title, controls, and the #fujita-legend)
    function applyLegendNudge(containerId = 'fujita-legend', extraPx = 16) {
      const inner = document.getElementById(containerId);
      if (!inner) return;
    
      // detect interactive
      const isInteractive = !!inner.querySelector('.legend-checkbox');
      // find the outer column containing the legend title and note
      let outer = inner.closest('.legend-right, .legend-column, .legend-left');
      if (!outer) {
        outer = inner;
        while (outer && outer.parentElement && !outer.parentElement.classList.contains('viz-legend-wrapper')) {
          outer = outer.parentElement;
        }
        // outer is now the child that sits directly under viz-legend-wrapper or the inner if not found
      }
    
      if (!outer) return;
    
      if (isInteractive) {
        outer.classList.add('legend-nudge');
        outer.style.marginLeft = (parseFloat(getComputedStyle(outer).marginLeft) || 0) + extraPx + 'px';
      } else {
        outer.classList.remove('legend-nudge');
        outer.style.marginLeft = '';
      }
    }

    // ------------------------
    // El Reno hodograph
    // ------------------------
    
    function renderAltitudeLegend(containerId, domainMin = 0, domainMax = 400) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = '';
    
      // compact container sizing
      container.style.display = 'inline-block';
      container.style.width = '120px';
      container.style.maxWidth = '120px';
      container.style.boxSizing = 'border-box';
      container.style.padding = '0';
      container.style.margin = '0';
    
      const svgW = 28;
      const svgH = 160;
      const paddingRight = 34;
      const totalW = svgW + paddingRight;
      const svgNS = 'http://www.w3.org/2000/svg';
    
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${totalW} ${svgH}`);
      svg.style.width = '100%';
      svg.style.height = 'auto';
      svg.style.display = 'block';
    
      const defs = document.createElementNS(svgNS, 'defs');
      const grad = document.createElementNS(svgNS, 'linearGradient');
      const gradId = `viridis_${containerId}`;
      grad.setAttribute('id', gradId);
      grad.setAttribute('x1', '0'); grad.setAttribute('y1', '0'); grad.setAttribute('x2', '0'); grad.setAttribute('y2', '1');
      [['0','#440154'],['25','#3b528b'],['50','#21918c'],['75','#5ec962'],['100','#fde725']]
        .forEach(([o,c]) => {
          const stop = document.createElementNS(svgNS,'stop');
          stop.setAttribute('offset', `${o}%`);
          stop.setAttribute('stop-color', c);
          grad.appendChild(stop);
        });
      defs.appendChild(grad);
      svg.appendChild(defs);
    
      const rect = document.createElementNS(svgNS, 'rect');
      rect.setAttribute('x', 0); rect.setAttribute('y', 8);
      rect.setAttribute('width', svgW); rect.setAttribute('height', svgH - 16);
      rect.setAttribute('fill', `url(#${gradId})`);
      svg.appendChild(rect);
    
      const g = document.createElementNS(svgNS, 'g');
      g.setAttribute('transform', `translate(${svgW + 6},0)`);
      const gradientInterior = svgH - 16;
      const ticks = [domainMin, domainMax * 0.25, domainMax * 0.5, domainMax * 0.75, domainMax];
      ticks.forEach(t => {
        const y = 8 + gradientInterior * (1 - (t - domainMin) / (domainMax - domainMin));
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', 0); line.setAttribute('x2', 6);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#333'); line.setAttribute('stroke-width', '0.6');
        g.appendChild(line);
        const txt = document.createElementNS(svgNS, 'text');
        txt.setAttribute('x', 10); txt.setAttribute('y', y + 4);
        txt.setAttribute('font-size', '11'); txt.setAttribute('fill', '#222');
        txt.textContent = Math.round(t);
        g.appendChild(txt);
      });
      svg.appendChild(g);
      container.appendChild(svg);
    
      // ensure ancestor wrapper not forcing width
      const sizeLegend = container.closest('.size-legend');
      if (sizeLegend) {
        sizeLegend.style.width = 'auto';
        sizeLegend.style.maxWidth = '140px';
        sizeLegend.style.boxSizing = 'border-box';
        sizeLegend.style.padding = '0';
      }
    }
    
    // ------------------------
    // Initialization: embed static specs and start dynamic maps
    // ------------------------
    async function init() {
      
      // Embed static JSON specs (they should be placed beside index.html or referenced by full path)
      
      await embedWithHtmlAnnotations("#viz-tornado-density", specs.tornadoDensity, { // embed the density visualisation and add annotations
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "victoria-hotspot",
            boxLonLat: { lon: 128, lat: -38 },
            label: "Southern Victoria experienced the\nmost recorded tornadoes (154)",
            nudgeX: -160,
            nudgeY: 20,
          },
          {
            id: "tropics-note",
            boxLonLat: { lon: 108, lat: -12 },
            label: "Tropics see more storms but\nfewer recorded tornadoes",
          }
        ]
      });

      drawTornadoSizeLegend();

      await embedWithHtmlAnnotations("#viz-severe-proportions", specs.severeProportions, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "sa-tornado-proportion",
            boxLonLat: { lon: 116.5, lat: -36.5 },
            label: "South Australia has the highest proportion\nof tornado-related severe weather — around 24%",
            leader: true,
            nudgeX: -40, 
            nudgeY: 10
          }
        ]
      });
      drawSevereLegendVertical(); 

      drawFujitaColorLegend('fujita-legend');
      applyLegendNudge('fujita-legend', -6);
      renderMaps();

      await embedWithHtmlAnnotations("#viz-fastest-aus", specs.fastestAus, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "wa-fastest",
            boxLonLat: { lon: 125.5, lat: -38.5 }, 
            label: "The fastest tornadoes in WA occurred in the 21st century",
            nudgeX: -180,                         
            nudgeY: -10                            
          },
          {
            id: "nsw-qld-note",
            boxLonLat: { lon: 162.0, lat: -20.0 }, 
            label: "NSW and QLD witness\nthe most tornadoes",
            nudgeX: -40,
            nudgeY: 8
          }
        ]
      });

      // US tornadoes by year and fujita rating
      await embedWithHtmlAnnotationsForCartesian("#viz-total-tornadoes", specs.totalTornadoes, {
        annotations: [
          {
            id: "peak-2011",
            lineStart: { x: 600, y: 34, coords: "px" }, 
            lineEnd:   { x: 705, y: 37, coords: "px" },  
          
            boxXY: { x: 1986, y: 2300 },
            nudgeX: 0,
            nudgeY: 0,
          
            label: "2011 saw the most tornadoes\nwith 2,074 recorded",
            maxWidth: 320,
            lineColor: "#000000",
            lineWidth: 1.0,
            lineOpacity: 0.95,
            edgeInset: 6
          },
          {
            id: "peak-1974-f5",
            lineStart: { x: 320, y: 190, coords: "px" },
            lineEnd:   { x: 320, y: 230, coords: "px" },
          
            boxXY: { x: 200, y: 140, coords: "px" },  
          
            nudgeX: 0,
            nudgeY: 0,
          
            label: "1974 had the most F5 tornadoes\nwith 25 recorded",
          
            maxWidth: 260,
            lineColor: "#000000",
            lineWidth: 1.0,
            lineOpacity: 0.95
          }
        ]
      });
      drawFujitaColorLegend("fujita-static-swatches", { interactive: false }); // this chart shouldn't have the toggle effect
            
      await embedWithHtmlAnnotationsForCartesian("#viz-by-month", specs.byMonth, {
        annotations: [
          {
            id: "au-season-note-unique-2025",
            boxXY: { x: 70, y: 250, coords: "px" }, 
            nudgeX: 0,
            nudgeY: 0,
            label: "Australia's tornado season\nis a lot less pronounced\nthan the United States",
            maxWidth: 260,
            lineColor: "#000000",
            lineWidth: 1.0,
            lineOpacity: 0.95
          },
          {
            id: "au-season-note-unique-2025",
            boxXY: { x: 550, y: 320, coords: "px" },  
            nudgeX: 0,
            nudgeY: 0,
            label: "The U.S. has over 20%\nof its recorded tornadoes in May",
            maxWidth: 260,
            lineColor: "#000000",
            lineWidth: 1.0,
            lineOpacity: 0.95
          }
        ]
      });
      drawCountryLegend("country-legend-swatches");

      await embedWithHtmlAnnotationsForCartesian("#viz-deadliest-bubble", specs.deadliestBubble, {
        annotations: [
          {
            id: "deadliest-bangladesh",
            lineStart: { x: 535, y: 90, coords: "px" }, 
            lineEnd:   { x: 715, y: 75, coords: "px" },
      
            boxXY: { x: 200, y: 50, coords: "px" },  
      
            nudgeX: 0,
            nudgeY: 0,
      
            label: "Deadliest recent tornado (Daulatpur-Saturia): densely populated areas with limited warning systems led to catastrophic loss of life",
      
            maxWidth: 340,
            lineColor: "#000000",
            lineWidth: 1.0,
            lineOpacity: 0.95
          }
        ]
      });

      drawDeadliestCountryLegend()

      await embedSpec("#viz-deadliest-map", specs.deadliestMap);
      drawDeadliestCountryLegend("deadliest-country-swatches-map");

      await embedWithHtmlAnnotationsForCartesian("#viz-el-reno-hodograph", specs.elRenoHodograph, {
        annotations: [
          {
            id: "curved-hodograph",
            boxXY: { x: 80, y: 310, coords: "px" },
            nudgeX: 0,
            nudgeY: 0,
            label: "It is clear that the wind speed increases and the wind direction changes with altitude",
            maxWidth: 240,
            fontSize: 14,
            padding: 10,
            lineOpacity: 0
          }
        ]
      });
      renderAltitudeLegend("el-reno-order-swatches", 0, 400);
    }

    // run
    init();
  </script>
</body>
</html>
</body>
</html>
