<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Severe Weather Visualisations</title>

  <!-- Vega / Vega-Lite / Vega-Embed -->
  <script src="https://cdn.jsdelivr.net/npm/vega@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-tooltip@1.1.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script> <!-- we use this to calculate projections and ensure annotations remain in the correct position -->

  <style>
    /* Basic tooltip element and visibility behavior (matches plugin expectations) */
    #vg-tooltip-element {
      visibility: hidden;
      position: fixed;
      z-index: 9999;
      padding: 10px 12px;
      max-width: 360px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.12);
      border: 1px solid rgba(34,40,49,0.08);
      font-family: "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      line-height: 1.3;
      pointer-events: none;          /* prevents blocking hover */
      transition: opacity 120ms ease, transform 120ms ease;
      transform-origin: left top;
      opacity: 0;
    }
    
    /* plugin uses .visible to show it */
    #vg-tooltip-element.visible {
      visibility: visible;
      opacity: 1;
      transform: translate3d(0,0,0) scale(1);
    }
    
    /* Provide a theme-specific wrapper class pattern the plugin may apply.
       The plugin may add "custom-theme" or "custom-theme-theme" depending on version.
       Include both to be safe. */
    #vg-tooltip-element.custom-theme,
    #vg-tooltip-element.custom-theme-theme,
    .custom-theme,
    .custom-theme-theme {
      background: linear-gradient(180deg, #fffdf3 0%, #fef3c7 100%);
      color: #111;
      border-color: rgba(34,40,49,0.08);
    }
    
    /* Table layout used by plugin for key/value pairs */
    #vg-tooltip-element table {
      border-spacing: 0;
      width: 100%;
    }
    #vg-tooltip-element table tr { border: none; }
    #vg-tooltip-element table tr td { padding: 4px 6px; vertical-align: middle; }
    
    /* Key / value classes the plugin emits */
    #vg-tooltip-element table tr td.key,
    #vg-tooltip-element .key {
      text-align: left;               /* change to left so highlighted chip aligns well */
      font-weight: 700;
      color: #234a7a;                 /* deep stormy blue for keys */
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
        
    /* Value styling */
    #vg-tooltip-element table tr td.value,
    #vg-tooltip-element .value {
      color: #0b6aa6;                 /* clear blue for numeric/text values */
      font-weight: 600;
      text-align: right;
    }

    /* Page and container */
    html,body { height:100%; margin:0; font-family: Helvetica, Arial, sans-serif; color:#111; }
    
    body {
      margin: 0;
      padding: 0;
      background-color: #e0e7ef; /* soft blue-gray background */
      background-repeat: repeat;
      background-size: auto;
      font-family: Helvetica, Arial, sans-serif;
      color: #111;
    }
    
    /* Outer poster container */
    .poster {
      max-width: 1100px;
      margin: 0 auto;
      padding-left: 40px; 
      padding-right: 20px; 
      padding-top: 56px; 
      padding-bottom: 40px; 
      background-color: #f4f7fb; /* light grey poster background */
      box-shadow: 0 0 40px rgba(0,0,0,0.1);
      border-radius: 12px;
    }

    /* Inner content layout */
    .page {
      display: flex;
      flex-direction: column;
      gap: 28px;
    }

    /* Image at the top of the page */
    .opening-image {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.75rem;
    }
    
    .opening-img {
      max-width: 640px;
      width: 80%;
      height: auto;
      display: block;
      border-radius: 6px;
    }

    /* Main page title */
    .page-title {
      font-size: 36px;
      font-weight: 700;
      color: #1f2a44; /* deep stormy blue */
      margin-bottom: 8px;
      text-align: center;
    }
    
    /* Subtitle under title */
    .page-subtitle {
      font-size: 20px;
      font-weight: 400;
      color: #4b5d7e; /* muted steel blue */
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Intro paragraph with narrow width and line breaks */
    .intro-paragraph {
      max-width: 700px;
      margin: 0 auto 32px auto;
      font-size: 16px;
      line-height: 1.6;
      color: #333;
      text-align: center;
    }
    
    /* Highlighted words */
    .highlight {
      color: #e07b39; /* weathered orange */
      font-weight: 600;
    }

    /* Each viz card */
    .viz-card {
      max-width: 1080px;
      margin-left: 1.5cm;
      margin-right: auto;
      position: relative;
    }
    
    .viz-title {
      font-size: 20px;
      font-weight: 700;
      color: #2c3e50; /* stormy navy */
      margin: 0 0 6px 0;
      text-align: left;
    }
    
    .viz-sub {
      font-size: 14px;
      color: #5c6e8c; /* steel blue-gray */
      margin: 0 0 16px 0;
      text-align: left;
    }

    /* Container */
    .viz-embed { position: relative; }
    
    /* Overlay SVG for leader lines (on top of canvas/svg) */
    .viz-embed .annotation-overlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 9998;
    }
    
    /* HTML annotation boxes: hug content, allow wrapping, standout font */
    .annotation-box {
      position: absolute;
      display: inline-block;           /* hug content width */
      transform: translate(0, 0);
      background: rgba(255,255,255,0.96);
      border: 1px solid rgba(34,40,49,0.08);
      padding: 8px 10px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      font-family: "Merriweather", Georgia, "Times New Roman", serif; /* standout serif */
      font-size: 14px;
      color: #1f2a44;
      max-width: 320px;               /* max width before wrapping */
      white-space: normal;            /* allow wrapping */
      line-height: 1.25;
      pointer-events: auto;
      z-index: 9999;
    }
    
    /* label element inside the box â€” keep bolder weight if desired */
    .annotation-box .annotation-label {
      font-weight: 700;
      letter-spacing: -0.2px;
      color: #123047;
    }
    
    /* if you ever want a smaller secondary line, leave this in place (not used now) */
    .annotation-box .caption {
      display: block;
      margin-top: 6px;
      color: #55607a;
      font-size: 12px;
      font-weight: 500;
    }
    
    /* marker and line unchanged */
    .annotation-marker { fill: #e07b39; stroke: #fff; stroke-width: 1.5px; }
    .annotation-line { stroke: #e07b39; stroke-width: 1.6px; stroke-linecap: round; opacity: 0.95; }

    /* Row for side-by-side maps (dynamic) */
    .row { display:flex; gap:16px; align-items:flex-start; justify-content:center; }
    .col { flex:1; min-width:280px; max-width:620px; }

    /* Small responsive tweaks */
    @media (max-width: 900px) {
      .row { flex-direction: column; }
    }

    /* header block that matches viz-left width and centering */
    .viz-header { display:flex; justify-content:flex-start; margin-bottom:8px; }
    .viz-title-block { width:100%; max-width:840px; box-sizing:border-box; }
    .viz-title, .viz-sub { margin:0; padding:0; }

    /* container that centers the chart+legend group */
    .viz-legend-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 24px;              /* small gap between viz and legend */
      padding: 12px 0;
    }

    /* make the left viz container a positioned block that can be sized by embed */
    .viz-left {
      flex: 0 0 840px;        /* fixed viz width that matches your Vega width */
      max-width: 100%;
      position: relative;
      box-sizing: border-box;
    }
    
    /* Ensure embed fills the left column */
    .viz-left .viz-embed,
    .viz-embed {
      width: 100% !important;
      max-width: 100% !important;
      height: auto;
    }
    
    .legend-right { 
      position: static !important; 
      top: auto !important; 
      right: auto !important; 
      z-index: auto !important; 
    }
    
    /* Legend styling */
    .size-legend {
      padding: 8px 10px;
      background: rgba(255,255,255,0.96);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      border: 1px solid rgba(34,40,49,0.08);
      max-width: 300px;
    }
    
    /* responsive: stack on narrow screens */
    @media (max-width: 880px) {
      .viz-legend-wrapper { flex-direction: column; align-items: center; }
      .legend-right { margin-left: 0; margin-top: 12px; }
    }

    /* Scoped rules for the stacked maps group only */
    .map-stack-left {
      flex: 0 1 auto;
      min-width: 320px;
      max-width: 840px;      /* tune to match other viz group width */
      display: block;
    }
    
    /* stack the two maps vertically and keep full width of the left column */
    .map-stack-left .map-stack-item {
      margin-bottom: 18px;
      width: 100%;
      box-sizing: border-box;
    }
    
    /* make embedded canvases use the exact left-column width */
    .map-stack-left .viz-embed {
      width: 840px;          /* keep same left-edge alignment as other visualisations */
      max-width: 100%;
    }

    // ----------------------------
    // Country legend style
    // ----------------------------

    #country-legend-swatches,
    #deadliest-country-swatches {
      display: flex !important;
      flex-direction: column !important;
      gap: 6px !important;          /* same as fujita */
      margin-top: 8px !important;
      padding: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* Each row: mirror fujita row sizing and alignment */
    #country-legend-swatches .f-row,
    #deadliest-country-swatches .f-row {
      display: flex !important;
      align-items: center !important;
      gap: 8px !important;
      font-size: 13px !important;   /* same as fujita */
      color: #123047 !important;
      padding: 0 !important;
      min-height: 20px !important;
      box-sizing: border-box !important;
    }
    
    /* Swatch styling to match fujita look (rect-like) */
    #country-legend-swatches .swatch,
    #deadliest-country-swatches .swatch {
      width: 24px !important;
      height: 14px !important;
      border-radius: 3px !important;
      border: 1px solid rgba(0,0,0,0.08) !important;
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06) !important;
      margin-right: 0 !important;
      flex: 0 0 auto !important;
      display: inline-block !important;
    }
    
    /* Label weight and description style */
    #country-legend-swatches .f-label,
    #deadliest-country-swatches .f-label {
      flex: 0 0 auto !important;
      font-weight: 700 !important;
      font-family: Inter, sans-serif !important;
      line-height: 1 !important;
      color: inherit !important;
    }
    
    /* Optional small description class if you use it */
    #country-legend-swatches .f-desc,
    #deadliest-country-swatches .f-desc {
      color: #55607a !important;
      font-weight: 500 !important;
      margin-left: 6px !important;
      font-size: 13px !important;
    }
    
    // ----------------------------
    // Fujita rating legend styles
    // ----------------------------

    .fujita-legend {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
    }
    
    .fujita-legend .f-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #123047;
    }
    
    .fujita-legend .swatch {
      width: 24px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: inset 0 -1px 0 rgba(0,0,0,0.06);
      flex: 0 0 auto;
    }
    
    .fujita-legend .f-label {
      flex: 0 0 auto;
      font-weight: 700;
    }
    
    .fujita-legend .f-desc {
      color: #55607a;
      font-weight: 500;
      margin-left: 6px;
    }

    .legend-item.disabled { opacity: 0.45; }
    .legend-item .legend-checkbox { margin-right: 8px; }

    // ----------------------------
    // El Reno
    // ----------------------------
    
    /* Two-column layout for El Reno with shared-height centring */
    .el-reno-image-row { margin-bottom: 18px; }
    
    /* Grid with fixed left column and right column for chart+legend */
    .el-reno-two-col {
      display: grid;
      grid-template-columns: 320px 1fr;
      column-gap: 28px;
      align-items: center;
      box-sizing: border-box;
      width: 100%;
      max-width: 1080px;
      padding-left: 24px;
    }
    
    /* LEFT: text column â€” fill the shared visual height and centre contents */
    .el-reno-left {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 480px;     /* shared visual baseline = hodograph height */
      box-sizing: border-box;
    }
    .el-reno-left .el-reno-narrow { margin: 0; max-width: 40ch; text-align: center; line-height: 1.6; }
    
    /* RIGHT: hodograph container â€” same min-height so both columns share vertical centre */
    .el-reno-right {
      position: relative;
      display: flex;
      align-items: center;   /* centre chart vertically inside the right column */
      justify-content: flex-start;
      min-height: 480px;     /* must match left min-height */
      box-sizing: border-box;
    }
    
    /* Ensure hodograph embed is exact size */
    #viz-el-reno-hodograph.viz-embed,
    #viz-el-reno-hodograph.viz-embed > svg,
    #viz-el-reno-hodograph.viz-embed > div,
    #viz-el-reno-hodograph.viz-embed iframe {
      display: block !important;
      width: 480px !important;
      height: 480px !important;
      margin: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* Legend: absolutely positioned relative to .el-reno-right so it doesn't affect flow */
    .el-reno-right .el-reno-legend-box {
      position: absolute;
      left: calc(480px + 12px); /* place to the right of the chart, adjust gap by changing 12px */
      top: 0;                   /* aligns top with chart top */
      width: 112px;
      padding: 6px;
      background: rgba(255,255,255,0.98);
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(16,24,40,0.06);
      border: 1px solid rgba(34,40,49,0.08);
      box-sizing: border-box;
      z-index: 50;
    }
    .el-reno-right .el-reno-legend-box .legend-title { font-size: 12px; font-weight: 700; margin-bottom: 6px; }
    .el-reno-right .el-reno-legend-box #el-reno-order-swatches,
    .el-reno-right .el-reno-legend-box #el-reno-order-swatches svg {
      width: 64px !important; height: auto !important; display: block !important;
    }
    
    /* Remove stray margins inside the two-col so centres align */
    .el-reno-two-col * { margin: 0; padding: 0; box-sizing: border-box; }
    
    /* Responsive fallback: stack on narrow screens */
    @media (max-width: 980px) {
      .el-reno-two-col { display: block; padding-left: 0; }
      .el-reno-left, .el-reno-right { min-height: auto; padding-left: 0; }
      #viz-el-reno-hodograph.viz-embed,
      #viz-el-reno-hodograph.viz-embed > svg,
      #viz-el-reno-hodograph.viz-embed > div,
      #viz-el-reno-hodograph.viz-embed iframe { width: 100% !important; height: auto !important; }
      .el-reno-right .el-reno-legend-box { position: static; left: auto; top: auto; width: 100%; margin-top: 8px; }
    }
  
  </style>
</head>
<body>
  <div class="poster">
    <div class="page">
      
      <div class="opening-image" aria-hidden="false" role="img" aria-label="Tornado illustration">
        <img src="tornado.jpg" alt="Tornado" class="opening-img" />
      </div>
      
      <h1 class="page-title">Tornadoes from the United States to Australia</h1>
      <h2 class="page-subtitle">
        When you think about tornadoes, you likely think about America.<br/>
        But Australia experiences <span class="highlight">around 100 tornadoes</span> a year.
      </h2>
      
      <p class="intro-paragraph">
        Tornadoes are one of the most <span class="highlight">violent</span> weather phenomena.<br/>
        They form under specific conditions: instability, moisture, and a lifting mechanism.<br/>
        Australiaâ€™s geography and climate make it <span class="highlight">ripe for severe storms</span>.<br/>
        Despite lower frequency than the U.S., tornadoes here can<br/>
        be <span class="highlight">just as destructive</span>.<br/>
        This page explores their patterns, strength, and impact.
      </p>

      <p class="intro-paragraph">
        Using the map below, inspect the locations where<br/>
        tornadoes are most common across Australia. 
      </p>
  
      <!-- 1) tornado_density_across_australia -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornado Density Across Australia between 1900 and 2025</h3>
            <p class="viz-sub">Aggregated by 3 degree bins and scaled by frequency.</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-tornado-density" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="tornado-size-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Tornado count</div>
              <svg id="tornado-size-legend-svg" role="img" aria-label="Tornado count legend"></svg>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        From the above map we can see that much of<br/>
        Australia experiences <span class="highlight">tornadoes</span>. The Bureau of Metereology (BOM)<br/>
        has a repository dedicated to <span class="highlight">severe weather</span>. Using this<br/>
        we can see how prevelant tornadoes are in<br/>
        comparison to other weather events.
      </p>
  
      <!-- 2) severe_weather_proportions_per_state -->
      <section class="viz-card">
        <h3 class="viz-title">Severe weather distribution between 1900 and 2025 by State</h3>
        <p class="viz-sub">ACT was excluded due to its small data size.</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-severe-proportions" class="viz-embed"></div>
          </div>
      
          <div class="legend-right">
            <div id="severe-legend" class="size-legend" aria-hidden="false">
              <div class="legend-title">Severe weather</div>
              <svg id="severe-legend-svg" width="200" height="140" role="img" aria-label="Severe weather legend"></svg>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        The <span class="highlight">Fujita rating</span> measures tornado strength.<br/>
        It was proposed in 1971 by Dr. Tetsuya Fujita.<br/>
        Dr. Fujita worked at the University of Chicago.<br/>
        Much research into severe storms focuses in the United States.<br/>
        The United States experiences a large number of <span class="highlight">tornadoes</span>.<br/>
        Tornadoes are unpredictable and difficult to study.<br/>
        Dr. Fujita proposed using a destruction scale to infer winds.<br/><br/>
        For example, destroying mobile homes requires winds above 180 km/h.<br/>
        If mobile homes are destroyed, winds must have reached that magnitude.<br/>
        Tornadoes are broadly categorised on the F0 to F5 scale.<br/>
        In 2007 the <span class="highlight">Enhanced Fujita</span> scale was introduced.<br/>
        The Enhanced Fujita refined the damage rating categories.
      </p>
  
      <!-- 3+4) dynamic maps row: Australian and US maps (vertically placed) -->
      <section class="viz-card">
        <div class="viz-header">
          <div class="viz-title-block">
            <h3 class="viz-title">Tornadoes by Fujita rating â€” Australia and U.S. bewteen 2010 and 2014.</h3>
            <p class="viz-sub">Dynamic maps generated from per-rating CSVs; toggle ratings using the checkboxes below. Inspect the locations that experienced the most tornadoes and the most severe tornadoes.</p>
          </div>
        </div>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left map-stack-left">
            <!-- stacked maps (vertical) -->
            <div id="aus-chart" class="viz-embed map-stack-item" aria-label="Australia tornado map"></div>
            <div id="us-chart" class="viz-embed map-stack-item" aria-label="United States tornado map"></div>
          </div>
      
          <div class="legend-right" aria-hidden="false" role="region" aria-label="Map legend and controls">
            <div id="combined-rating-legend" class="size-legend" role="group" aria-label="Fujita rating legend">
              <div class="legend-title">Fujita rating</div>
      
              <div id="legend-checkboxes" aria-label="Fujita rating toggles" role="list"></div>
      
              <!-- color swatches + descriptions rendered by drawFujitaColorLegend -->
              <div id="fujita-legend" class="fujita-legend" role="list" aria-label="Fujita scale colours"></div>
      
              <!-- optional small help text -->
              <div class="legend-note" style="margin-top:8px; color:#55607a; font-size:12px;">
                Toggle ratings to show or hide that class on the maps.
              </div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        The above map really puts into perspective the number<br/>
        of tornadoes the U.S. gets each year.<br/><br/>
        Look at the below graph to get an idea of<br/>
        how the number of recorded tornadoes has changed<br/>
        and how many are <span class="highlight">damaging tornadoes</span>.
      </p>

      <!-- 5) tornadoes_by_fujita_rating_and_year -->
      <section class="viz-card">
        <h3 class="viz-title">The Number of Recorded Tornadoes in the U.S. since 1950</h3>
        <p class="viz-sub">The values are broken down by fujita rating.</p>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-total-tornadoes" class="viz-embed"></div>
          </div>

          <div class="legend-right" aria-hidden="false" role="region" aria-label="Fujita scale legend">
            <div id="fujita-static-legend" class="size-legend" role="group" aria-label="Fujita scale colours">
              <div class="legend-title">Fujita Scale</div>
              <div id="fujita-static-swatches" class="fujita-legend" role="list" aria-label="Fujita scale colours"></div>
            </div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Whilst Australia obviously experiences <span class="highlight">far fewer servere tornado events</span><br/>
        than the United States, we still experience strong tornadoes<br/>
        with the fastest being <span class="highlight">F4 rated</span>.<br/><br/>
        As noted before. Wind speeds are <span class="highlight">estimated based on damage</span>.<br/> 
        When the BOM is surveying tornado damage, they estimate the<br/>
        associated wind strength. Use the time sliders in the<br/>
        below visualisation to see the <span class="highlight">fastest tornadoes</span><br/>
        in a given period.
      </p>
  
      <!-- 6) fastest_australian_tornadoes -->
      <section class="viz-card">
        <h3 class="viz-title">Top Five Fastest Tornadoes by Wind Speed Since 1900</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-fastest-aus" class="viz-embed"></div>
          </div>
        </div>
      </section>

      <p class="intro-paragraph">
        Tornadoes are <span class="highlight">very seasonal events</span>. They require certain conditions to<br/>
        occur, such as a <span class="highlight">lifting mechanism</span>, a <span class="highlight">moist atmosphere</span><br/>
        and also <span class="highlight">conditional instability</span>. Because of this,<br/>
        <span class="highlight">Spring</span> is the most common season to experience tornadoes,<br/>
        although they can happen at <span class="highlight">any time of the year</span>.<br/>
        View below the distribution of tornadoes across months in<br/>
        <span class="highlight">Australia</span> â€” a Southern Hemisphere country â€” and the<br/>
        <span class="highlight">United States</span> â€” a Northern Hemisphere country.
      </p>

      <!-- 7) tornadoes_by_month_aus_vs_us -->
      <section class="viz-card">
        <h3 class="viz-title">Tornadoes by month â€” Australia vs U.S.</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-by-month" class="viz-embed"></div>
          </div>

        <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
          <div id="country-legend" class="size-legend" role="group" aria-label="Country colours">
            <div class="legend-title">Country</div>
            <div id="country-legend-swatches" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
          </div>
        </div>
        </div>
      </section>
        
      <p class="intro-paragraph">
        With <span class="highlight">wind speeds high enough to shred</span><br/>
        a well-built house off its foundations,<br/>
        tornadoes have sadly <span class="highlight">claimed many lives</span>.<br/>
        See below a chart of some of the<br/>
        <span class="highlight">deadliest tornadoes of all time</span>.
      </p>
  
      <!-- 8) deadliest_tornadoes_bubble_chart -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes â€” bubble chart</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-deadliest-bubble" class="viz-embed"></div>
          </div>

          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="deadliest-country-legend" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="deadliest-country-swatches" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        See the general locations of the deadliest<br/>
        tornadoes visualised on a map.
      </p>
   
      <!-- 9) deadliest_tornadoes_on_a_map -->
      <section class="viz-card">
        <h3 class="viz-title">Deadliest tornadoes on a map</h3>
      
        <div class="viz-legend-wrapper">
          <div class="viz-left">
            <div id="viz-deadliest-map" class="viz-embed"></div>
          </div>

          <div class="legend-right" aria-hidden="false" role="region" aria-label="Country legend">
            <div id="deadliest-country-legend-map" class="size-legend" role="group" aria-label="Country colours">
              <div class="legend-title">Country</div>
              <div id="deadliest-country-swatches-map" class="fujita-legend" role="list" aria-label="Country colour swatches"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- 10) El-reno example -->
      <section class="viz-card el-reno-block" aria-labelledby="el-reno-title">
        <h3 id="el-reno-title" class="viz-title">El Reno Tornado â€” profile and hodograph</h3>
      
        <!-- IMAGE ROW: back in place -->
        <div class="el-reno-image-row">
          <figure class="el-reno-figure">
            <img src="el-reno.jpg" alt="El Reno tornado, May 2013" width="900" height="506" loading="lazy">
            <figcaption class="el-reno-caption">The El Reno tornado, May 2013 â€” one of the largest observed.</figcaption>
          </figure>
        </div>
      
        <!-- TWO-COLUMN ROW: left = text, right = hodograph + legend -->
        <div class="el-reno-two-col" role="region" aria-label="El Reno text and hodograph">
          <div class="el-reno-left">
            <p class="el-reno-narrow">
              Wind shear that <span class="highlight">turns</span> and <span class="highlight">increases</span> with height
              helps create the rotation seen in the hodograph. The final sounding after the tornado shows strong
              lowâ€‘level curvature and speed increases, indicating streamwise vorticity being tilted into the updraft.
            </p>
          </div>
      
          <div class="el-reno-right">
            <div id="viz-el-reno-hodograph" class="viz-embed" aria-label="El Reno hodograph"></div>
      
            <div class="el-reno-legend-box" aria-hidden="false">
              <div class="legend-title">Altitude (m)</div>
              <div id="el-reno-order-swatches" class="fujita-legend" role="list" aria-label="Altitude colours"></div>
            </div>
          </div>
        </div>
      </section>
      
      <p class="intro-paragraph">
        In conclusion, <span class="highlight">Australia has experienced its share of tornadoes</span><br/>
        and severe weather, with notable events scattered across<br/>
        the continent. However, the <span class="highlight">United States remains the global epicenter</span><br/>
        of tornado activity â€” both in frequency and intensity.<br/>
        This visualisation explored the <span class="highlight">seasonal nature of tornadoes</span>,<br/>
        the role of <span class="highlight">wind shear and hodographs</span> in supercell formation,<br/>
        and highlighted some of the <span class="highlight">deadliest</span> and <span class="highlight">fastest tornadoes</span> on record.<br/>
        We examined <span class="highlight">dot maps</span> showing where tornadoes occur most often<br/>
        in both the U.S. and Australia, and reviewed the<br/>
        <span class="highlight">distribution of severe weather across Australia</span>.<br/>
        Together, these insights help us better understand the<br/>
        <span class="highlight">patterns, risks, and dynamics</span> of tornado formation<br/>
        across hemispheres.
      </p>
    </div>
  </div>

  <script>
    // ------------------------
    // Configuration
    // ------------------------

    // JSON spec filenames placed beside index.html in the same repo/folder
    const specs = {
      tornadoDensity: "tornado_density_across_australia.json",
      severeProportions: "severe_weather_proportions_per_state.json",
      fastestAus: "fastest_australian_tornadoes.json",
      totalTornadoes: "tornadoes_by_fujita_rating_and_year.json",
      byMonth: "tornadoes_by_month_aus_vs_us.json",
      deadliestBubble: "deadliest_tornadoes_bubble_chart.json",
      deadliestMap: "deadliest_tornadoes_on_a_map.json",
      elRenoHodograph: "el-reno_hodograph.json",
    };

    // CSV / topo repo used for dynamic maps (the repo you used previously)
    // If you want to change the repo, update this base path.
    const csvRepoBase = "https://raw.githubusercontent.com/James-Monash/3179-Week-10-Assignment/main/";

    // Patterns and topo files (update repo path if needed)
    const ausCsvPattern = csvRepoBase + "Tornado_F{R}_2010_2024_Australia.csv";
    const usCsvPattern  = csvRepoBase + "Tornado_F{R}_2010_2024_America.csv";

    const ausBaseTopo = csvRepoBase + "australia.json";
    const ausGraticules = csvRepoBase + "10_degree_graticules_for_australia.json";

    const usBaseTopo = csvRepoBase + "mainland_united_states.json";
    const usGraticules = csvRepoBase + "10_degree_graticules_for_united_states.json";

    // Fujita rating colours and list (initial selection: all)
    const ratingColors = {
      "F0": "#999999",
      "F1": "#E69F00",
      "F2": "#56B4E9",
      "F3": "#009E73",
      "F4": "#F0E442",
      "F5": "#984ea3"
    };
    const ratings = ["F0","F1","F2","F3","F4","F5"];
    let selectedRatings = new Set(ratings);

    // Latitude/longitude field names in the CSVs
    const ausLatField = "Latitude";
    const ausLonField = "Longitude";
    const usLatField = "BEGIN_LAT";
    const usLonField = "BEGIN_LON";

    // ------------------------
    // Helpers
    // ------------------------

    async function embedSpec(target, urlOrSpec) {
      try {
        await vegaEmbed(target, urlOrSpec, { 
          actions: false, 
          renderer: "canvas",
          tooltip: { 
            theme: 'custom',
            disableDefaultStyle: true
          }
        });
      } catch (err) {
        document.querySelector(target).innerHTML = "<div style='padding:12px;color:#900;'>Failed to render: " + (err.message || err) + "</div>";
        console.error("Embed error", err);
      }
    }

    async function fetchCsv(url) {
      try {
        const r = await fetch(url);
        if (!r.ok) return [];
        const text = await r.text();
        const lines = text.trim().split(/\r?\n/);
        if (lines.length === 0) return [];
        const cols = lines[0].split(",");
        const rows = [];
        for (let i=1;i<lines.length;i++){
          const vals = lines[i].split(",");
          const obj = {};
          for (let j=0;j<cols.length;j++){
            obj[cols[j]] = vals[j] !== undefined ? vals[j] : "";
          }
          rows.push(obj);
        }
        return rows;
      } catch (e) {
        console.warn("CSV fetch failed", url, e);
        return [];
      }
    }

    // ------------------------
    // Creating legends 
    // ------------------------

    function drawTornadoSizeLegend(containerId = "tornado-size-legend-svg") {
      const domain = [1, 160];
      const rangeArea = [50, 840]; // same as Vega-Lite size scale (area in px^2)
      const counts = [150, 100, 30, 1]; // draw largest first (top) â€” change order if you prefer
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // helpers
      const areaForCount = c => {
        const t = (c - domain[0]) / (domain[1] - domain[0]);
        return rangeArea[0] + t * (rangeArea[1] - rangeArea[0]);
      };
      const radiusForArea = a => Math.sqrt(a / Math.PI);
    
      // clear
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      // layout params
      const paddingLeft = 12;
      const paddingTop = 12;
      const itemGap = 12;         // vertical gap between items
      const labelGap = 8;         // horizontal gap between circle and label
      const labelFontSize = 12;
    
      // compute radii and max width needed
      const radii = counts.map(c => radiusForArea(areaForCount(c)));
      const maxR = Math.max(...radii);
      const circleColWidth = Math.ceil(2 * maxR); // column reserved for circle diameter
      const labelColWidth = 70;                    // reserve for labels (adjust if needed)
    
      // initial positions
      let y = paddingTop;
    
      counts.forEach((c, i) => {
        const r = radii[i];
        const cx = paddingLeft + maxR;           // center circles in left column
        const cy = y + r;
    
        // circle
        const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circ.setAttribute("cx", cx);
        circ.setAttribute("cy", cy);
        circ.setAttribute("r", r);
        circ.setAttribute("fill", "#0072B2");
        circ.setAttribute("fill-opacity", "0.85");
        circ.setAttribute("stroke", "#fff");
        circ.setAttribute("stroke-width", "1");
        svg.appendChild(circ);
    
        // label to the right of circle
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + circleColWidth + labelGap);
        label.setAttribute("y", cy + (labelFontSize / 3)); // vertically align text near center
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.textContent = String(c);
        svg.appendChild(label);
    
        // advance y for next item: circle diameter + gap
        y += Math.ceil(2 * r + itemGap);
      });
    
      // finalize svg size
      const totalWidth = paddingLeft + circleColWidth + labelGap + labelColWidth + 12;
      const totalHeight = y + 8;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function drawSevereLegendVertical(containerId = "severe-legend-svg") {
      // color mapping (matches your glyph colors)
      const items = [
        { key: "rain_mentions", label: "Rain", color: "#0072B2" },
        { key: "hail_mentions", label: "Hail", color: "#009E73" },
        { key: "tornado_mentions", label: "Tornado", color: "#D55E00" }
      ];
    
      const svg = document.getElementById(containerId);
      if (!svg) return;
    
      // layout params chosen to match visual footprint of the tornado vertical legend
      const paddingLeft = 12;
      const paddingTop = 12;
      const swatchSize = 18;    // square swatch size
      const itemGap = 14;       // vertical gap between items
      const labelGap = 10;      // horizontal gap between swatch and label
      const labelFontSize = 12;
    
      // clear existing content
      while (svg.firstChild) svg.removeChild(svg.firstChild);
    
      let y = paddingTop;
    
      items.forEach((it, i) => {
        // swatch (rounded rect)
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", paddingLeft);
        rect.setAttribute("y", y);
        rect.setAttribute("width", swatchSize);
        rect.setAttribute("height", swatchSize);
        rect.setAttribute("rx", 3);
        rect.setAttribute("ry", 3);
        rect.setAttribute("fill", it.color);
        rect.setAttribute("stroke", "#fff");
        rect.setAttribute("stroke-width", "1");
        svg.appendChild(rect);
    
        // label text
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", paddingLeft + swatchSize + labelGap);
        label.setAttribute("y", y + swatchSize - 4);
        label.setAttribute("fill", "#123047");
        label.setAttribute("font-size", String(labelFontSize));
        label.setAttribute("class", "severe-legend-swatch-label");
        label.textContent = it.label;
        svg.appendChild(label);
    
        y += swatchSize + itemGap;
      });
    
      const totalWidth = paddingLeft + swatchSize + labelGap + 80;
      const totalHeight = y + 6;
      svg.setAttribute("width", totalWidth);
      svg.setAttribute("height", totalHeight);
    }

    function makeLegendRows(container, items, colors, opts = {}) {
      const swW = opts.swatchWidth || 24;
      const swH = opts.swatchHeight || 14;
      if (!container) return;
    
      container.innerHTML = "";
      container.style.display = "flex";
      container.style.flexDirection = "column";
      container.style.gap = "6px";
      container.style.marginTop = "8px";
      container.style.boxSizing = "border-box";
    
      items.forEach(labelText => {
        const row = document.createElement("div");
        row.className = "f-row";
        row.setAttribute("role", "listitem");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.gap = "8px";
        row.style.fontSize = "13px";
        row.style.color = "#123047";
        row.style.padding = "0";
        row.style.minHeight = "20px";
        row.style.boxSizing = "border-box";
    
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.width = swW + "px";
        sw.style.height = swH + "px";
        sw.style.background = colors[labelText] || "#999";
        sw.style.borderRadius = "3px";
        sw.style.border = "1px solid rgba(0,0,0,0.08)";
        sw.style.boxShadow = "inset 0 -1px 0 rgba(0,0,0,0.06)";
        sw.style.display = "inline-block";
        sw.setAttribute("aria-hidden", "true");
    
        const label = document.createElement("span");
        label.className = "f-label";
        label.textContent = labelText;
        label.style.fontWeight = "700";
        label.style.fontFamily = "Inter, sans-serif";
        label.style.lineHeight = "1";
        label.style.display = "inline-block";
    
        row.appendChild(sw);
        row.appendChild(label);
        container.appendChild(row);
      });
    }
    
    function drawCountryLegend(containerId = "country-legend-swatches") {
      const container = document.getElementById(containerId);
      if (!container) return;
      const countries = ["Australia", "America"];
      const countryColors = { "Australia": "#0072B2", "America": "#D55E00" };
      makeLegendRows(container, countries, countryColors, { swatchWidth: 24, swatchHeight: 14 });
    }
    
    function drawDeadliestCountryLegend(containerId = "deadliest-country-swatches") {
      const container = document.getElementById(containerId);
      if (!container) return;
      const countries = ["Bangladesh","United States","Russia","Italy","Malta","Argentina","Australia"];
      const countryColors = {
        "Bangladesh": "#E69F00",
        "United States": "#56B4E9",
        "Russia": "#009E73",
        "Italy": "#F0E442",
        "Malta": "#0072B2",
        "Argentina": "#D55E00",
        "Australia": "#CC79A7"
      };
      makeLegendRows(container, countries, countryColors, { swatchWidth: 24, swatchHeight: 14 });
    }
    
    // ------------------------
    // Adding annotations
    // ------------------------

    /* Charts */

    async function embedWithHtmlAnnotationsForCartesian(target, specUrlOrObject, options = {}) {
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = Object.assign({
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      }, options.embedOptions || {});
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
      if (view && typeof view.runAsync === "function") await view.runAsync();
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      // create/replace overlay SVG for leader lines and markers
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function getScaleFn(scaleName) {
        try {
          if (!view || typeof view.scale !== "function") return null;
          const s = view.scale(scaleName);
          if (typeof s !== "function") return null;
          return s;
        } catch (e) {
          return null;
        }
      }
    
      function dataToPixels(xVal, yVal) {
        const xScale = getScaleFn('x') || getScaleFn('xscale') || getScaleFn('xscale0') || null;
        const yScale = getScaleFn('y') || getScaleFn('yscale') || getScaleFn('yscale0') || null;
        const px = xScale ? xScale(xVal) : null;
        const py = yScale ? yScale(yVal) : null;
        return { x: px, y: py };
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        // clear overlay lines and boxes
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
        // create boxes first (so we can measure)
        const created = annotations.map(a => {
          const src = a.src || {};
          // compute anchor pixel from src (used for marker + start of line)
          let anchorPx = null;
          if (typeof src.x === "number" && typeof src.y === "number") {
            const pt = dataToPixels(src.x, src.y);
            if (pt.x != null && pt.y != null) anchorPx = pt;
          }
    
          // compute box position from boxXY (preferred) or fallback to src
          const boxCoord = (a.boxXY && typeof a.boxXY.x === "number" && typeof a.boxXY.y === "number")
            ? a.boxXY
            : (typeof src.x === "number" && typeof src.y === "number" ? { x: src.x, y: src.y } : null);
    
          if (!boxCoord) return null;
          const boxPx = dataToPixels(boxCoord.x, boxCoord.y);
          if (boxPx.x == null || boxPx.y == null) return null;
    
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
          div.style.position = "absolute";
          div.style.pointerEvents = "auto";
    
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
    
          // default placement: box at projected boxPx + nudges
          let leftPx = boxPx.x + nudgeX;
          let topPx  = boxPx.y + nudgeY;
    
          // append off-DOM to measure size
          div.style.left = "-9999px";
          div.style.top = "-9999px";
          container.appendChild(div);
          const measured = div.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const w = Math.min(boxMaxWidth, measured.width);
          const h = measured.height;
    
          // adjust left/top to fit inside container bounds
          const margin = 8;
          if (leftPx + margin + w > width) leftPx = Math.max(margin, width - w - margin);
          if (leftPx < margin) leftPx = margin;
          if (topPx < margin) topPx = margin;
          if (topPx > height - 40) topPx = height - 40;
    
          div.style.left = Math.round(leftPx) + "px";
          div.style.top  = Math.round(topPx) + "px";
    
          return { a, div, anchorPx, left: leftPx, top: topPx, width: w, height: h };
        }).filter(Boolean);
    
        // draw leader lines from anchor to nearest box edge and markers where anchor exists
        created.forEach(c => {
          const anchor = c.anchorPx;
          if (!anchor) return; // no anchor => no line/marker
    
          const boxLeft = c.left;
          const boxRight = c.left + c.width;
          const boxTop = c.top;
          const boxBottom = c.top + c.height;
    
          // pick attachment point on box edge (prefer left edge if box is left of anchor)
          let attachX, attachY;
          if (anchor.x > boxRight) {
            attachX = boxRight;
            attachY = Math.min(Math.max(anchor.y, boxTop), boxBottom);
          } else if (anchor.x < boxLeft) {
            attachX = boxLeft;
            attachY = Math.min(Math.max(anchor.y, boxTop), boxBottom);
          } else if (anchor.y < boxTop) {
            attachY = boxTop;
            attachX = Math.min(Math.max(anchor.x, boxLeft), boxRight);
          } else {
            attachY = boxBottom;
            attachX = Math.min(Math.max(anchor.x, boxLeft), boxRight);
          }
    
          // draw line (explicit stroke defaulting to black)
          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", Math.round(anchor.x));
          line.setAttribute("y1", Math.round(anchor.y));
          line.setAttribute("x2", Math.round(attachX));
          line.setAttribute("y2", Math.round(attachY));
          line.setAttribute("class", "annotation-line");
          line.setAttribute("stroke", (c.a && c.a.lineColor) ? c.a.lineColor : "#000000");
          line.setAttribute("stroke-width", (c.a && c.a.lineWidth) ? String(c.a.lineWidth) : "1.2");
          line.setAttribute("stroke-opacity", (c.a && c.a.lineOpacity) ? String(c.a.lineOpacity) : "0.95");
          overlay.appendChild(line);
    
          // draw marker at anchor (explicit fill/stroke defaults)
          const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          marker.setAttribute("cx", Math.round(anchor.x));
          marker.setAttribute("cy", Math.round(anchor.y));
          marker.setAttribute("r", (c.a && c.a.markerRadius) ? String(c.a.markerRadius) : "4");
          marker.setAttribute("class", "annotation-marker");
          marker.setAttribute("fill", (c.a && c.a.markerFill) ? c.a.markerFill : "#000000");
          marker.setAttribute("stroke", (c.a && c.a.markerStroke) ? c.a.markerStroke : "#ffffff");
          overlay.appendChild(marker);
        });
    
        return created;
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on resize or view updates
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
    
      // observe container size changes
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }
    /* Map annotations */
    
    async function embedWithHtmlAnnotations(target, specUrlOrObject, options = {}) {
      const projOpts = Object.assign({
        type: "mercator",
        center: [134, -28],
        scale: 850
      }, options.projection || {});
    
      const annotations = Array.isArray(options.annotations) ? options.annotations : [];
    
      let spec;
      if (typeof specUrlOrObject === "string") {
        const res = await fetch(specUrlOrObject);
        if (!res.ok) throw new Error("Failed to fetch spec: " + res.statusText);
        spec = await res.json();
      } else {
        spec = JSON.parse(JSON.stringify(specUrlOrObject));
      }
    
      const embedOptions = {
        actions: false,
        renderer: "canvas",
        tooltip: { theme: "custom", disableDefaultStyle: true }
      };
    
      const result = await vegaEmbed(target, spec, embedOptions);
      const view = result && result.view;
    
      if (view && typeof view.runAsync === "function") {
        await view.runAsync();
      }
    
      const container = document.querySelector(target);
      if (!container) throw new Error("Embed target not found: " + target);
      if (getComputedStyle(container).position === "static") container.style.position = "relative";
    
      // create/replace overlay SVG (kept for compatibility but not used for lines/markers)
      let overlay = container.querySelector(".annotation-overlay");
      if (overlay) overlay.remove();
      overlay = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      overlay.setAttribute("class", "annotation-overlay");
      overlay.setAttribute("preserveAspectRatio", "xMinYMin meet");
      overlay.style.position = "absolute";
      overlay.style.left = "0";
      overlay.style.top = "0";
      overlay.style.width = "100%";
      overlay.style.height = "100%";
      overlay.style.pointerEvents = "none";
      container.appendChild(overlay);
    
      // remove previous boxes
      Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
      function makeProjection(width, height) {
        const vw = (view && typeof view.width === "function") ? view.width() : width;
        const vh = (view && typeof view.height === "function") ? view.height() : height;
        const geo = (typeof d3 !== "undefined" && typeof d3.geoMercator === "function") ? d3 : null;
        if (!geo) throw new Error("d3.geoMercator not available; include d3 (e.g. https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js)");
        return geo.geoMercator().center(projOpts.center).scale(projOpts.scale).translate([vw / 2, vh / 2]);
      }
    
      function drawAnnotations() {
        const bbox = container.getBoundingClientRect();
        const width = Math.max(20, Math.floor(bbox.width));
        const height = Math.max(20, Math.floor(bbox.height));
    
        overlay.setAttribute("width", width);
        overlay.setAttribute("height", height);
        overlay.style.width = width + "px";
        overlay.style.height = height + "px";
    
        const proj = makeProjection(width, height);
        function projectPoint(lon, lat) {
          const p = proj([lon, lat]);
          return { x: p[0], y: p[1] };
        }
    
        // clear overlay contents and previous boxes
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
        Array.from(container.querySelectorAll(".annotation-box")).forEach(n => n.remove());
    
        // create boxes only (no lines or markers)
        const createdBoxes = annotations.map(a => {
          // prefer explicit boxLonLat for where the HTML box should sit
          const boxLon = (a.boxLonLat && typeof a.boxLonLat.lon === "number") ? a.boxLonLat.lon
                        : (a.src && typeof a.src.lon === "number" ? a.src.lon : null);
          const boxLat = (a.boxLonLat && typeof a.boxLonLat.lat === "number") ? a.boxLonLat.lat
                        : (a.src && typeof a.src.lat === "number" ? a.src.lat : null);
    
          // if we still don't have coords, skip this annotation
          if (boxLon === null || boxLat === null) return null;
    
          const boxPx = projectPoint(boxLon, boxLat);
    
          const div = document.createElement("div");
          div.className = "annotation-box";
          if (a.id) div.setAttribute("data-annotation-id", a.id);
    
          const label = document.createElement("div");
          label.className = "annotation-label";
          label.innerHTML = (a.label || "").replace(/\n/g, "<br>");
          div.appendChild(label);
    
          if (a.caption) {
            const cap = document.createElement("div");
            cap.className = "caption";
            cap.textContent = a.caption;
            div.appendChild(cap);
          }
    
          const nudgeX = Number.isFinite(a.nudgeX) ? a.nudgeX : 0;
          const nudgeY = Number.isFinite(a.nudgeY) ? a.nudgeY : 0;
    
          let left = Math.round(boxPx.x + container.scrollLeft + nudgeX);
          let top  = Math.round(boxPx.y + container.scrollTop + nudgeY);
    
          const containerRect = container.getBoundingClientRect();
          const boxMaxWidth = (a.maxWidth && Number.isFinite(a.maxWidth)) ? a.maxWidth : 320;
          const margin = 8;
    
          if (left + margin + boxMaxWidth > containerRect.width) left = Math.max(margin, containerRect.width - boxMaxWidth - margin);
          if (left < margin) left = margin;
          if (top < margin) top = margin;
          if (top > containerRect.height - 40) top = containerRect.height - 40;
    
          div.style.left = left + "px";
          div.style.top  = top + "px";
    
          container.appendChild(div);
    
          return {
            a,
            div,
            left,
            top,
            width: Math.min(boxMaxWidth, div.getBoundingClientRect().width),
            height: div.getBoundingClientRect().height,
            anchorPx: boxPx
          };
        }).filter(Boolean);
    
        // no leader lines or markers are created
        return createdBoxes;
      }
    
      // initial draw
      drawAnnotations();
    
      // redraw on window + container resize
      let resizeTimer;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      const ro = new ResizeObserver(() => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(drawAnnotations, 120);
      });
      ro.observe(container);
    
      return { result, drawAnnotations, annotations, resizeObserver: ro };
    }

    // ------------------------
    // Dynamic maps (Australia and US) logic
    // ------------------------

    function drawFujitaColorLegend(containerId = "fujita-legend", opts = {}) {
      const container = document.getElementById(containerId);
      if (!container) return;
    
      const interactive = opts.interactive !== false; // default to true
      const descriptions = opts.descriptions || {
        "F0": "Gale damage",
        "F1": "Moderate damage",
        "F2": "Considerable damage",
        "F3": "Severe damage",
        "F4": "Devastating damage",
        "F5": "Incredible damage"
      };
    
      container.innerHTML = "";
    
      ratings.forEach(r => {
        const row = document.createElement("div");
        row.className = "f-row legend-item";
        row.setAttribute("role", "listitem");
        row.setAttribute("data-rating", r);
    
        if (interactive) {
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.className = "legend-checkbox";
          cb.value = r;
          cb.checked = selectedRatings.has(r);
          cb.setAttribute("aria-label", r + " toggle");
          cb.addEventListener("change", onLegendToggle);
          row.appendChild(cb);
    
          row.addEventListener("click", (e) => {
            if (e.target === cb) return;
            cb.checked = !cb.checked;
            cb.dispatchEvent(new Event("change", { bubbles: true }));
          });
    
          if (!cb.checked) row.classList.add("disabled");
        }
    
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = ratingColors[r] || "#ccc";
        sw.setAttribute("aria-hidden", "true");
    
        const label = document.createElement("span");
        label.className = "f-label legend-label";
        label.textContent = r;
    
        const desc = document.createElement("span");
        desc.className = "f-desc legend-desc";
        desc.textContent = descriptions[r] || "";
    
        row.appendChild(sw);
        row.appendChild(label);
        row.appendChild(desc);
    
        container.appendChild(row);
      });
    }

    function onLegendToggle(e) {
      const rating = e.target.value;
      const checked = e.target.checked;
      const item = e.target.closest(".legend-item");
      if (!item) return;
      if (!checked) {
        selectedRatings.delete(rating);
        item.classList.add("disabled");
      } else {
        selectedRatings.add(rating);
        item.classList.remove("disabled");
      }
      renderMaps(); // re-render maps with updated selectedRatings
    }

    async function renderMaps() {
      // build base layers
      const ausLayers = [
        {
          data: { url: ausBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: ausGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      const usLayers = [
        {
          data: { url: usBaseTopo, format: { type: "topojson", feature: "ne_50m_admin_1_states_provinces" } },
          mark: { type: "geoshape", fill: "#f7f3ea", stroke: "#999", strokeWidth: 1 }
        },
        {
          data: { url: usGraticules, format: { type: "topojson", feature: "ne_50m_graticules_10" } },
          mark: { type: "geoshape", stroke: "#ccc", strokeWidth: 0.9 }
        }
      ];

      // gather per-rating point layers (only for selected ratings)
      for (const r of ratings) {
        if (!selectedRatings.has(r)) continue;

        const ausUrl = ausCsvPattern.replace("{R}", r.slice(1));
        const usUrl  = usCsvPattern.replace("{R}", r.slice(1));

        // fetch CSVs (graceful if missing)
        const [ausRows, usRows] = await Promise.all([fetchCsv(ausUrl), fetchCsv(usUrl)]);

        const ausValues = ausRows.map(row => {
          const out = Object.assign({}, row);
          if (out[ausLatField] !== undefined) out[ausLatField] = parseFloat(out[ausLatField]);
          if (out[ausLonField] !== undefined) out[ausLonField] = parseFloat(out[ausLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        const usValues = usRows.map(row => {
          const out = Object.assign({}, row);
          if (out[usLatField] !== undefined) out[usLatField] = parseFloat(out[usLatField]);
          if (out[usLonField] !== undefined) out[usLonField] = parseFloat(out[usLonField]);
          out.TOR_F_SCALE = out.TOR_F_SCALE || r;
          return out;
        });

        // push a point layer for this rating
        ausLayers.push({
          data: { values: ausValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: ausLonField, type: "quantitative" },
            latitude: { field: ausLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });

        usLayers.push({
          data: { values: usValues },
          mark: { type: "point", filled: true, size: 36 },
          encoding: {
            longitude: { field: usLonField, type: "quantitative" },
            latitude: { field: usLatField, type: "quantitative" },
            color: { value: ratingColors[r] },
            tooltip: [{ title: "Fujita rating", field: "TOR_F_SCALE", type: "nominal" }]
          }
        });
      } // end per-rating loop

      // Construct final specs
      const ausSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 840,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [134, -28], scale: 850 },
        layer: ausLayers,
        config: { view: { stroke: null } }
      };

      const usSpec = {
        $schema: "https://vega.github.io/schema/vega-lite/v6.json",
        width: 840,
        height: 600,
        background: "#c6dbef",
        projection: { type: "mercator", center: [-98, 38], scale: 750 },
        layer: usLayers,
        config: { view: { stroke: null } }
      };
      
      document.getElementById("aus-chart").innerHTML = "";
      document.getElementById("us-chart").innerHTML = "";
      
      // set spec widths consistent with CSS viz-left width (840)
      ausSpec.width = 840;
      usSpec.width = 840;
      
      await embedWithHtmlAnnotations("#aus-chart", ausSpec, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          // Alice Springs area â€” moved further left and line break after "central"
          {
            id: "alice-springs-note",
            boxLonLat: { lon: 128.5, lat: -22.5 },
            label: "Recorded tornadoes in central\nAustralia are extremely rare",
            nudgeX: -60,
            nudgeY: -10
          },
      
          // Offshore south of WA â€” moved ~5Â° south and a bit east
          {
            id: "wa-coast-note",
            boxLonLat: { lon: 116.0, lat: -36.5 },
            label: "Notice tornadoes cluster near populated areas; others may occur unrecorded offshore or remote inland",
            nudgeX: -180,
            nudgeY: 8
          }
        ]
      });

      await embedWithHtmlAnnotations("#us-chart", usSpec, {
        projection: { center: [-95, 37], scale: 900 },
        annotations: [
          {
            id: "ca-offshore-note",
            // anchor point can be near the western interior (used only if you supplied src previously)
            src: { lon: -119.0, lat: 30.0 },
            // place the HTML box so its left edge is approximately in line with California (lon -120)
            // and positioned ~5Â° north of Washington (~lat 52)
            boxLonLat: { lon: -117.0, lat: 52.0 },
            label: "Tornadoes are less common in the western US but still occur",
            nudgeX: -12,
            nudgeY: -6,
            maxWidth: 320
          },
      
          {
            id: "southeast-note",
            // keep anchor near Alabama if you want the logical association, but move box position west a bit
            src: { lon: -86.9, lat: 32.3 },
            // box moved west so it sits more over the central Gulf / lower Mississippi longitudes
            boxLonLat: { lon: -90.5, lat: 30.0 },
            label: "Dangerous tornadoes are concentrated in the southeast states",
            nudgeX: -40,
            nudgeY: 10,
            maxWidth: 300
          }
        ]
      });
    }

    // ------------------------
    // El Reno hodograph
    // ------------------------
    
    function renderAltitudeLegend(containerId, domainMin = 0, domainMax = 400) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.innerHTML = '';
    
      // compact container sizing
      container.style.display = 'inline-block';
      container.style.width = '120px';
      container.style.maxWidth = '120px';
      container.style.boxSizing = 'border-box';
      container.style.padding = '0';
      container.style.margin = '0';
    
      const svgW = 28;
      const svgH = 160;
      const paddingRight = 34;
      const totalW = svgW + paddingRight;
      const svgNS = 'http://www.w3.org/2000/svg';
    
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${totalW} ${svgH}`);
      svg.style.width = '100%';
      svg.style.height = 'auto';
      svg.style.display = 'block';
    
      const defs = document.createElementNS(svgNS, 'defs');
      const grad = document.createElementNS(svgNS, 'linearGradient');
      const gradId = `viridis_${containerId}`;
      grad.setAttribute('id', gradId);
      grad.setAttribute('x1', '0'); grad.setAttribute('y1', '0'); grad.setAttribute('x2', '0'); grad.setAttribute('y2', '1');
      [['0','#440154'],['25','#3b528b'],['50','#21918c'],['75','#5ec962'],['100','#fde725']]
        .forEach(([o,c]) => {
          const stop = document.createElementNS(svgNS,'stop');
          stop.setAttribute('offset', `${o}%`);
          stop.setAttribute('stop-color', c);
          grad.appendChild(stop);
        });
      defs.appendChild(grad);
      svg.appendChild(defs);
    
      const rect = document.createElementNS(svgNS, 'rect');
      rect.setAttribute('x', 0); rect.setAttribute('y', 8);
      rect.setAttribute('width', svgW); rect.setAttribute('height', svgH - 16);
      rect.setAttribute('fill', `url(#${gradId})`);
      svg.appendChild(rect);
    
      const g = document.createElementNS(svgNS, 'g');
      g.setAttribute('transform', `translate(${svgW + 6},0)`);
      const gradientInterior = svgH - 16;
      const ticks = [domainMin, domainMax * 0.25, domainMax * 0.5, domainMax * 0.75, domainMax];
      ticks.forEach(t => {
        const y = 8 + gradientInterior * (1 - (t - domainMin) / (domainMax - domainMin));
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', 0); line.setAttribute('x2', 6);
        line.setAttribute('y1', y); line.setAttribute('y2', y);
        line.setAttribute('stroke', '#333'); line.setAttribute('stroke-width', '0.6');
        g.appendChild(line);
        const txt = document.createElementNS(svgNS, 'text');
        txt.setAttribute('x', 10); txt.setAttribute('y', y + 4);
        txt.setAttribute('font-size', '11'); txt.setAttribute('fill', '#222');
        txt.textContent = Math.round(t);
        g.appendChild(txt);
      });
      svg.appendChild(g);
      container.appendChild(svg);
    
      // ensure ancestor wrapper not forcing width
      const sizeLegend = container.closest('.size-legend');
      if (sizeLegend) {
        sizeLegend.style.width = 'auto';
        sizeLegend.style.maxWidth = '140px';
        sizeLegend.style.boxSizing = 'border-box';
        sizeLegend.style.padding = '0';
      }
    }
    
    // ------------------------
    // Initialization: embed static specs and start dynamic maps
    // ------------------------
    async function init() {
      
      // Embed static JSON specs (they should be placed beside index.html or referenced by full path)
      
      await embedWithHtmlAnnotations("#viz-tornado-density", specs.tornadoDensity, { // embed the density visualisation and add annotations
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "victoria-hotspot",
            boxLonLat: { lon: 128, lat: -38 },
            label: "Southern Victoria experienced the\nmost recorded tornadoes",
            nudgeX: -160,
            nudgeY: 20,
          },
          {
            id: "tropics-note",
            boxLonLat: { lon: 108, lat: -12 },
            label: "Tropics see more storms but\nfewer recorded tornadoes",
          }
        ]
      });

      drawTornadoSizeLegend();

      await embedWithHtmlAnnotations("#viz-severe-proportions", specs.severeProportions, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          {
            id: "sa-tornado-proportion",
            boxLonLat: { lon: 116.5, lat: -36.5 },
            label: "South Australia has the highest proportion\nof tornado-related severe weather â€” around 24%",
            leader: true,
            nudgeX: -40,                             // slightly reduced nudge
            nudgeY: 10
          }
        ]
      });
      drawSevereLegendVertical(); 

      drawFujitaColorLegend('fujita-legend');
      renderMaps();

      await embedWithHtmlAnnotations("#viz-fastest-aus", specs.fastestAus, {
        projection: { center: [134, -28], scale: 850 },
        annotations: [
          // Western Australia note (on land in WA)
          {
            id: "wa-fastest",
            boxLonLat: { lon: 125.5, lat: -43.5 }, // where the annotation box should sit
            label: "The fastest tornadoes in WA occurred in the 21st century",
            nudgeX: -180,                           // tune horizontal pixel offset for box
            nudgeY: -10                             // tune vertical pixel offset for box
          },
      
          // Queensland / NSW coastal note (placed offshore/coast)
          {
            id: "nsw-qld-note",
            boxLonLat: { lon: 162.0, lat: -20.0 }, // box near coast between QLD and NSW
            label: "NSW and QLD witness\nthe most tornadoes",
            nudgeX: -40,
            nudgeY: 8
          }
        ]
      });

      // US tornadoes by year and fujita rating
      await embedWithHtmlAnnotationsForCartesian("#viz-total-tornadoes", specs.totalTornadoes, {
        annotations: [
          {
            id: "peak-2011",
            // anchor at the data point (Year, Count)
            src: { x: 2011, y: 2074 },
      
            // move the HTML box further left and slightly higher than before
            boxXY: { x: 1978, y: 2350 },
      
            // label text with a line break
            label: "2011 saw the most tornadoes\nwith 2,074 recorded",
      
            // small pixel nudges after projection (tweak if needed)
            nudgeX: -6,
            nudgeY: -6,
      
            // visual tuning
            maxWidth: 320,
            lineColor: "#e07b39",
            lineWidth: 1.6,
            lineOpacity: 0.95,
            markerRadius: 4,
            markerFill: "#e07b39",
            markerStroke: "#ffffff"
          }
        ]
      });
      drawFujitaColorLegend("fujita-static-swatches", { interactive: false }); // this chart shouldn't have the toggle effect
      
      // other later static specs
      await embedSpec("#viz-by-month", specs.byMonth);
      drawCountryLegend("country-legend-swatches");

      await embedSpec("#viz-deadliest-bubble", specs.deadliestBubble);
      drawDeadliestCountryLegend()
      
      await embedSpec("#viz-deadliest-map", specs.deadliestMap);
      drawDeadliestCountryLegend("deadliest-country-swatches-map");

      await embedSpec("#viz-el-reno-hodograph", specs.elRenoHodograph);
      renderAltitudeLegend("el-reno-order-swatches", 0, 400);
    }

    // run
    init();
  </script>
</body>
</html>
</body>
</html>
